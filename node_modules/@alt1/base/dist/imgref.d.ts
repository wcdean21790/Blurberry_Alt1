import { RectLike } from "./rect";
/**
 * Represents an image that might be in different types of memory
 * This is mostly used to represent images still in Alt1 memory that have
 * not been transfered to js yet. Various a1lib api's use this type and
 * choose the most efficient approach based on the memory type
 */
export declare abstract class ImgRef {
    width: number;
    height: number;
    x: number;
    y: number;
    t: string;
    constructor(x: number, y: number, w: number, h: number);
    read(x?: number, y?: number, w?: number, h?: number): ImageData;
    findSubimage(needle: ImageData, sx?: number, sy?: number, w?: number, h?: number): {
        x: number;
        y: number;
    }[];
    toData(x?: number, y?: number, w?: number, h?: number): ImageData;
    containsArea(rect: RectLike): boolean;
}
/**
 * Represents an image in js render memory (canvas/image tag)
 */
export declare class ImgRefCtx extends ImgRef {
    ctx: CanvasRenderingContext2D;
    constructor(img: HTMLImageElement | CanvasRenderingContext2D | HTMLCanvasElement, x?: number, y?: number);
    read(x?: number, y?: number, w?: number, h?: number): ImageData;
}
/**
 * Represents in image in Alt1 memory, This type of image can be searched for subimages
 * very efficiently and transfering the full image to js can be avoided this way
 */
export declare class ImgRefBind extends ImgRef {
    handle: number;
    constructor(handle: number, x?: number, y?: number, w?: number, h?: number);
    read(x?: number, y?: number, w?: number, h?: number): ImageData;
}
/**
 * Represents an image in js memory
 */
export declare class ImgRefData extends ImgRef {
    buf: ImageData;
    constructor(buf: ImageData, x?: number, y?: number);
    read(x?: number, y?: number, w?: number, h?: number): ImageData;
}
//# sourceMappingURL=imgref.d.ts.map