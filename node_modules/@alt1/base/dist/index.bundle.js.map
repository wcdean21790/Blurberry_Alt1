{"version":3,"file":"index.bundle.js","mappings":"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","sources":["webpack://A1lib/webpack/universalModuleDefinition","webpack://A1lib/webpack/bootstrap","webpack://A1lib/webpack/runtime/define property getters","webpack://A1lib/webpack/runtime/hasOwnProperty shorthand","webpack://A1lib/webpack/runtime/make namespace object","webpack://A1lib/./imgref.ts","webpack://A1lib/./rect.ts","webpack://A1lib/./imagedata-extensions.ts","webpack://A1lib/./nodepolyfill.ts","webpack://A1lib/./wrapper.ts","webpack://A1lib/./imagedetect.ts","webpack://A1lib/./pasteinput.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@alt1/base\"] = factory();\n\telse\n\t\troot[\"A1lib\"] = factory();\n})((typeof self!='undefined'?self:this), () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { ImageDetect, transferImageData } from \"./index\";\r\nimport { RectLike } from \"./rect\";\r\n\r\n/**\r\n * Represents an image that might be in different types of memory\r\n * This is mostly used to represent images still in Alt1 memory that have\r\n * not been transfered to js yet. Various a1lib api's use this type and\r\n * choose the most efficient approach based on the memory type\r\n */\r\nexport abstract class ImgRef {\r\n\tpublic width: number;\r\n\tpublic height: number;\r\n\tpublic x: number;\r\n\tpublic y: number;\r\n\tpublic t = \"none\";\r\n\r\n\tconstructor(x: number, y: number, w: number, h: number) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.width = w;\r\n\t\tthis.height = h;\r\n\t}\r\n\r\n\tread(x = 0, y = 0, w = this.width, h = this.height): ImageData {\r\n\t\tthrow new Error(\"This imgref (\" + this.t + \") does not support toData\");\r\n\t}\r\n\r\n\tfindSubimage(needle: ImageData, sx = 0, sy = 0, w = this.width, h = this.height) {\r\n\t\treturn ImageDetect.findSubimage(this, needle, sx, sy, w, h);\r\n\t}\r\n\ttoData(x = this.x, y = this.y, w = this.width, h = this.height) {\r\n\t\treturn this.read(x - this.x, y - this.y, w, h);\r\n\t};\r\n\tcontainsArea(rect: RectLike) {\r\n\t\treturn this.x <= rect.x && this.y <= rect.y && this.x + this.width >= rect.x + rect.width && this.y + this.height >= rect.y + rect.height;\r\n\t}\r\n}\r\n\r\n/**\r\n * Represents an image in js render memory (canvas/image tag)\r\n */\r\nexport class ImgRefCtx extends ImgRef {\r\n\tctx: CanvasRenderingContext2D;\r\n\tconstructor(img: HTMLImageElement | CanvasRenderingContext2D | HTMLCanvasElement, x = 0, y = 0) {\r\n\t\tif (img instanceof CanvasRenderingContext2D) {\r\n\t\t\tsuper(x, y, img.canvas.width, img.canvas.height);\r\n\t\t\tthis.ctx = img;\r\n\t\t} else {\r\n\t\t\tsuper(x, y, img.width, img.height);\r\n\t\t\tvar cnv = (img instanceof HTMLCanvasElement ? img : img.toCanvas());\r\n\t\t\tthis.ctx = cnv.getContext(\"2d\")!;\r\n\t\t}\r\n\t\tthis.t = \"ctx\";\r\n\t}\r\n\r\n\tread(x = 0, y = 0, w = this.width, h = this.height) {\r\n\t\treturn this.ctx.getImageData(x, y, w, h);\r\n\t}\r\n}\r\n\r\n/**\r\n * Represents in image in Alt1 memory, This type of image can be searched for subimages \r\n * very efficiently and transfering the full image to js can be avoided this way\r\n */\r\nexport class ImgRefBind extends ImgRef {\r\n\thandle: number;\r\n\tconstructor(handle: number, x = 0, y = 0, w = 0, h = 0) {\r\n\t\tsuper(x, y, w, h);\r\n\t\tthis.handle = handle;\r\n\t\tthis.t = \"bind\";\r\n\t}\r\n\r\n\tread(x = 0, y = 0, w = this.width, h = this.height) {\r\n\t\treturn transferImageData(this.handle, x, y, w, h);\r\n\t}\r\n}\r\n\r\n/**\r\n * Represents an image in js memory\r\n */\r\nexport class ImgRefData extends ImgRef {\r\n\tbuf: ImageData;\r\n\tconstructor(buf: ImageData, x = 0, y = 0) {\r\n\t\tsuper(x, y, buf.width, buf.height);\r\n\t\tthis.buf = buf;\r\n\t\tthis.t = \"data\";\r\n\t}\r\n\r\n\tread(x = 0, y = 0, w = this.width, h = this.height) {\r\n\t\tif (x == 0 && y == 0 && w == this.width && h == this.height) {\r\n\t\t\treturn this.buf;\r\n\t\t}\r\n\t\tvar r = new ImageData(w, h);\r\n\t\tfor (var b = y; b < y + h; b++) {\r\n\t\t\tfor (var a = x; a < x + w; a++) {\r\n\t\t\t\tvar i1 = (a - x) * 4 + (b - y) * w * 4;\r\n\t\t\t\tvar i2 = a * 4 + b * 4 * this.buf.width;\r\n\r\n\t\t\t\tr.data[i1] = this.buf.data[i2];\r\n\t\t\t\tr.data[i1 + 1] = this.buf.data[i2 + 1];\r\n\t\t\t\tr.data[i1 + 2] = this.buf.data[i2 + 2];\r\n\t\t\t\tr.data[i1 + 3] = this.buf.data[i2 + 3];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn r;\r\n\t}\r\n}\r\n","//util class for rectangle maths\r\n//TODO shit this sucks can we remove it again?\r\n//more of a shorthand to get {x,y,width,height} than a class\r\n//kinda starting to like it again\r\n//TODO remove rant\r\n\r\nexport interface PointLike {\r\n\tx: number,\r\n\ty: number\r\n};\r\n\r\nexport interface RectLike {\r\n\tx: number;\r\n\ty: number;\r\n\twidth: number;\r\n\theight: number;\r\n}\r\n\r\n/**\r\n * Simple rectangle class with some util functions\r\n */\r\nexport default class Rect implements RectLike {\r\n\tx: number;\r\n\ty: number;\r\n\twidth: number;\r\n\theight: number;\r\n\tconstructor(x: number, y: number, w: number, h: number) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.width = w;\r\n\t\tthis.height = h;\r\n\t}\r\n\r\n\tstatic fromArgs(...args: [RectLike] | [x: number, y: number, w: number, h: number]): Rect {\r\n\t\tif (typeof args[0] == \"object\") {\r\n\t\t\treturn new Rect(args[0].x, args[0].y, args[0].width, args[0].height);\r\n\t\t} else if (typeof args[0] == \"number\" && args.length >= 4) {\r\n\t\t\treturn new Rect(args[0], args[1]!, args[2]!, args[3]!);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"invalid rect args\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Resizes this Rect to include the full size of a given second rectangle\r\n\t */\r\n\tunion(r2: RectLike) {\r\n\t\tvar x = Math.min(this.x, r2.x);\r\n\t\tvar y = Math.min(this.y, r2.y);\r\n\t\tthis.width = Math.max(this.x + this.width, r2.x + r2.width) - x;\r\n\t\tthis.height = Math.max(this.y + this.height, r2.y + r2.height) - y;\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t * Resizes this Rect to include a given point\r\n\t */\r\n\tincludePoint(x: number, y: number) {\r\n\t\tthis.union(new Rect(x, y, 0, 0));\r\n\t}\r\n\t/**\r\n\t * Grows the rectangle with the given dimensions\r\n\t */\r\n\tinflate(w: number, h: number) {\r\n\t\tthis.x -= w;\r\n\t\tthis.y -= h;\r\n\t\tthis.width += 2 * w;\r\n\t\tthis.height += 2 * h;\r\n\t}\r\n\t/**\r\n\t * Resizes this Rect to the area that overlaps a given Rect\r\n\t * width and height will be set to 0 if the intersection does not exist\r\n\t */\r\n\tintersect(r2: RectLike) {\r\n\t\tif (this.x < r2.x) { this.width -= r2.x - this.x; this.x = r2.x; }\r\n\t\tif (this.y < r2.y) { this.height -= r2.y - this.y; this.y = r2.y; }\r\n\t\tthis.width = Math.min(this.x + this.width, r2.x + r2.width) - this.x;\r\n\t\tthis.height = Math.min(this.y + this.height, r2.y + r2.height) - this.y;\r\n\t\tif (this.width <= 0 || this.height <= 0) {\r\n\t\t\tthis.width = 0;\r\n\t\t\tthis.height = 0;\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * Returns wether this Rect has at least one pixel overlap with a given Rect\r\n\t */\r\n\toverlaps(r2: RectLike) {\r\n\t\treturn this.x < r2.x + r2.width && this.x + this.width > r2.x && this.y < r2.y + r2.height && this.y + this.height > r2.y;\r\n\t}\r\n\t/**\r\n\t * Returns wether a given Rect fits completely inside this Rect\r\n\t * @param r2\r\n\t */\r\n\tcontains(r2: RectLike) {\r\n\t\treturn this.x <= r2.x && this.x + this.width >= r2.x + r2.width && this.y <= r2.y && this.y + this.height >= r2.y + r2.height;\r\n\t}\r\n\t/**\r\n\t * Returns wether a given point lies inside this Rect\r\n\t */\r\n\tcontainsPoint(x: number, y: number) {\r\n\t\treturn this.x <= x && this.x + this.width > x && this.y <= y && this.y + this.height > y;\r\n\t}\r\n}","import * as a1lib from \"./index\";\r\nimport * as nodeimports from \"./nodepolyfill\";\r\n\r\ndeclare global {\r\n\tinterface ImageData {\r\n\t\tputImageData(buf: ImageData, cx: number, cy: number): void;\r\n\t\tpixelOffset(x: number, y: number): number;\r\n\t\tgetPixelHash(rect: a1lib.RectLike): number;\r\n\r\n\t\tclone(rect: a1lib.RectLike): ImageData;\r\n\r\n\t\tshow: {\r\n\t\t\t(x?: number, y?: number, zoom?: number): HTMLCanvasElement;\r\n\t\t\tmaxImages: number;\r\n\t\t}\r\n\r\n\t\ttoDrawableData(): ImageData;\r\n\t\ttoImage(rect?: a1lib.RectLike): HTMLCanvasElement;\r\n\r\n\t\tgetPixel(x: number, y: number): [number, number, number, number];\r\n\t\tgetPixelValueSum(x: number, y: number): number;\r\n\t\tgetPixelInt(x: number, y: number): number;\r\n\t\tgetColorDifference(x: number, y: number, r: number, g: number, b: number, a?: number): number;\r\n\r\n\r\n\t\tsetPixel(x: number, y: number, color: [number, number, number, number]): void;\r\n\t\tsetPixel(x: number, y: number, r: number, g: number, b: number, a: number): void;\r\n\r\n\t\tsetPixelInt(x: number, y: number, color: number): void;\r\n\r\n\t\ttoFileBytes(format: \"image/png\" | \"image/webp\", quality?: any): Promise<Uint8Array>;\r\n\t\ttoPngBase64(): string;\r\n\r\n\t\tpixelCompare(buf: ImageData, x?: number, y?: number, max?: number): number;\r\n\r\n\t\tcopyTo(target: ImageData, sourcex: number, sourcey: number, width: number, height: number, targetx: number, targety: number): void;\r\n\t}\r\n\r\n\tinterface HTMLImageElement {\r\n\t\ttoBuffer(x?: number, y?: number, w?: number, h?: number): ImageData;\r\n\t\ttoCanvas(x?: number, y?: number, w?: number, h?: number): HTMLCanvasElement;\r\n\t}\r\n}\r\n\r\ntype ImageDataConstr = {\r\n\tprototype: ImageData;\r\n\tnew(width: number, height: number): ImageData;\r\n\tnew(array: Uint8ClampedArray, width: number, height: number): ImageData;\r\n};\r\n\r\n\r\n//export this so node.js can also use it\r\nexport var ImageData: ImageDataConstr;\r\n\r\n// //TODO revamp this madness a bit?\r\n// (function () {\r\n// \tvar globalvar = (typeof self != \"undefined\" ? self : (typeof (global as any) != \"undefined\" ? (global as any) : null)) as any;\r\n// \t//use the node-canvas version when on node\r\n// \tif (typeof globalvar.ImageData == \"undefined\") {\r\n// \t\tlet nodecnv = requireNodeCanvas();\r\n// \t\tglobalvar.ImageData = nodecnv.ImageData;\r\n// \t}\r\n// \tvar fill = typeof globalvar.ImageData == \"undefined\";\r\n\r\n// \t//should never be reach anymore\r\n// \tvar constr = function (this: any) {\r\n// \t\tvar i = 0;\r\n// \t\tvar data = (arguments[i] instanceof Uint8ClampedArray ? arguments[i++] : null);\r\n// \t\tvar width = arguments[i++];\r\n// \t\tvar height = arguments[i++];\r\n\r\n// \t\tif (fill) {\r\n// \t\t\tif (!data) { data = new Uint8ClampedArray(width * height * 4); }\r\n// \t\t\tthis.width = width;\r\n// \t\t\tthis.height = height;\r\n// \t\t\tthis.data = data;\r\n// \t\t}\r\n// \t\telse if (oldconstr) {\r\n// \t\t\treturn (data ? new oldconstr(data, width, height) : new oldconstr(width, height));\r\n// \t\t} else {\r\n// \t\t\tvar canvas = document.createElement('canvas');\r\n// \t\t\tcanvas.width = width;\r\n// \t\t\tcanvas.height = height;\r\n// \t\t\tvar ctx = canvas.getContext(\"2d\")!;\r\n// \t\t\tvar imageData = ctx.createImageData(width, height);\r\n// \t\t\tif (data) { imageData.data.set(data); }\r\n// \t\t\treturn imageData;\r\n// \t\t}\r\n// \t}\r\n\r\n// \tvar oldconstr = globalvar.ImageData;\r\n// \tif (typeof document != \"undefined\") {\r\n// \t\ttry {\r\n// \t\t\tnew oldconstr(1, 1);\r\n// \t\t} catch (e) {\r\n// \t\t\t//direct constructor call not allowed in ie\r\n// \t\t\toldconstr = null;\r\n// \t\t}\r\n// \t}\r\n\r\n// \tif (!fill) { constr.prototype = globalvar.ImageData.prototype; }\r\n// \tglobalvar.ImageData = constr;\r\n// \tImageData = constr as any;\r\n// })();\r\n\r\n\r\n(function () {\r\n\tvar globalvar = (typeof self != \"undefined\" ? self : (typeof (global as any) != \"undefined\" ? (global as any) : null)) as any;\r\n\tvar filltype = typeof globalvar.ImageData == \"undefined\" || typeof globalvar.document == \"undefined\";\r\n\tvar fillconstr = filltype;\r\n\tif (!filltype) {\r\n\t\tvar oldconstr = globalvar.ImageData;\r\n\t\ttry {\r\n\t\t\tlet data = new Uint8ClampedArray(4);\r\n\t\t\tdata[0] = 1;\r\n\t\t\tlet a = new globalvar.ImageData(data, 1, 1);\r\n\t\t\tfillconstr = a.data[0] != 1;\r\n\t\t} catch (e) {\r\n\t\t\tfillconstr = true;\r\n\t\t}\r\n\t}\r\n\r\n\tif (fillconstr) {\r\n\t\tvar constr = function ImageDataShim(this: any) {\r\n\t\t\tvar i = 0;\r\n\t\t\tvar data = (arguments[i] instanceof Uint8ClampedArray ? arguments[i++] : null);\r\n\t\t\tvar width = arguments[i++];\r\n\t\t\tvar height = arguments[i++];\r\n\r\n\t\t\tif (filltype) {\r\n\t\t\t\tif (!data) { data = new Uint8ClampedArray(width * height * 4); }\r\n\t\t\t\tthis.width = width;\r\n\t\t\t\tthis.height = height;\r\n\t\t\t\tthis.data = data;\r\n\t\t\t}\r\n\t\t\telse if (fillconstr) {\r\n\t\t\t\t//WARNING This branch of code does not use the same pixel data backing store\r\n\t\t\t\t//(problem with wasm, however all wasm browser have a native constructor (unless asm.js is used))\r\n\t\t\t\tvar canvas = document.createElement('canvas');\r\n\t\t\t\tcanvas.width = width;\r\n\t\t\t\tcanvas.height = height;\r\n\t\t\t\tvar ctx = canvas.getContext(\"2d\")!;\r\n\t\t\t\tvar imageData = ctx.createImageData(width, height);\r\n\t\t\t\tif (data) { imageData.data.set(data); }\r\n\t\t\t\treturn imageData;\r\n\t\t\t}\r\n\t\t\t// else {\r\n\t\t\t// \t//oh no...\r\n\t\t\t// \t//we need this monstrocity in order to call the native constructor with variable number of args\r\n\t\t\t// \t//when es5 transpile is enable (that strips the spread operator)\r\n\t\t\t// \treturn new (Function.prototype.bind.apply(oldconstr, [null,...arguments]));\r\n\t\t\t// }\r\n\t\t}\r\n\t\tif (!filltype) { constr.prototype = globalvar.ImageData.prototype; }\r\n\t\tglobalvar.ImageData = constr;\r\n\t\tImageData = constr as any;\r\n\t} else {\r\n\t\tImageData = globalvar.ImageData;\r\n\t}\r\n})();\r\n\r\n//Recast into a drawable imagedata class on all platforms, into a normal browser ImageData on browsers or a node-canvas imagedata on nodejs\r\nImageData.prototype.toDrawableData = function () {\r\n\tif (typeof document == \"undefined\") {\r\n\t\treturn nodeimports.imageDataToDrawable(this);\r\n\t} else {\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nImageData.prototype.putImageData = function (buf, cx, cy) {\r\n\tfor (var dx = 0; dx < buf.width; dx++) {\r\n\t\tfor (var dy = 0; dy < buf.height; dy++) {\r\n\t\t\tvar i1 = (dx + cx) * 4 + (dy + cy) * 4 * this.width;\r\n\t\t\tvar i2 = dx * 4 + dy * 4 * buf.width;\r\n\t\t\tthis.data[i1] = buf.data[i2];\r\n\t\t\tthis.data[i1 + 1] = buf.data[i2 + 1];\r\n\t\t\tthis.data[i1 + 2] = buf.data[i2 + 2];\r\n\t\t\tthis.data[i1 + 3] = buf.data[i2 + 3];\r\n\t\t}\r\n\t}\r\n}\r\n\r\nImageData.prototype.pixelOffset = function (x, y) {\r\n\treturn x * 4 + y * this.width * 4;\r\n}\r\n\r\n//creates a hash of a portion of the buffer used to check for changes\r\nImageData.prototype.getPixelHash = function (rect) {\r\n\tif (!rect) { rect = new a1lib.Rect(0, 0, this.width, this.height); }\r\n\tvar hash = 0;\r\n\tfor (var x = rect.x; x < rect.x + rect.width; x++) {\r\n\t\tfor (var y = rect.y; y < rect.y + rect.height; y++) {\r\n\t\t\tvar i = x * 4 + y * 4 * this.width;\r\n\r\n\t\t\thash = (((hash << 5) - hash) + this.data[i]) | 0;\r\n\t\t\thash = (((hash << 5) - hash) + this.data[i + 1]) | 0;\r\n\t\t\thash = (((hash << 5) - hash) + this.data[i + 2]) | 0;\r\n\t\t\thash = (((hash << 5) - hash) + this.data[i + 3]) | 0;\r\n\t\t}\r\n\t}\r\n\treturn hash;\r\n}\r\n\r\nImageData.prototype.clone = function (rect) {\r\n\treturn this.toImage(rect).getContext(\"2d\")!.getImageData(0, 0, rect.width, rect.height);\r\n}\r\n\r\nImageData.prototype.show = function (this: ImageData, x = 5, y = 5, zoom = 1) {\r\n\tif (typeof document == \"undefined\") {\r\n\t\tconsole.error(\"need a document to show an imagedata object\");\r\n\t\treturn;\r\n\t}\r\n\tvar imgs = document.getElementsByClassName(\"debugimage\");\r\n\twhile (imgs.length > ImageData.prototype.show.maxImages) { imgs[0].remove(); }\r\n\tvar el = this.toImage();\r\n\tel.classList.add(\"debugimage\")\r\n\tel.style.position = \"absolute\";\r\n\tel.style.zIndex = \"1000\";\r\n\tel.style.left = x / zoom + \"px\";\r\n\tel.style.top = y / zoom + \"px\";\r\n\tel.style.background = \"purple\";\r\n\tel.style.cursor = \"pointer\";\r\n\tel.style.imageRendering = \"pixelated\";\r\n\tel.style.outline = \"1px solid #0f0\";\r\n\tel.style.width = (this.width == 1 ? 100 : this.width) * zoom + \"px\";\r\n\tel.style.height = (this.height == 1 ? 100 : this.height) * zoom + \"px\";\r\n\tel.onclick = function () { el.remove(); }\r\n\tdocument.body.appendChild(el);\r\n\treturn el;\r\n} as typeof ImageData[\"prototype\"][\"show\"];\r\nImageData.prototype.show.maxImages = 10;\r\n\r\nImageData.prototype.toImage = function (this: ImageData, rect?) {\r\n\tif (!rect) { rect = new a1lib.Rect(0, 0, this.width, this.height); }\r\n\tif (typeof document != \"undefined\") {\r\n\t\tvar el = document.createElement(\"canvas\");\r\n\t\tel.width = rect.width;\r\n\t\tel.height = rect.height;\r\n\t} else {\r\n\t\tel = nodeimports.createCanvas(rect.width, rect.height);\r\n\t}\r\n\tvar ctx = el.getContext(\"2d\")!;\r\n\tctx.putImageData(this.toDrawableData(), -rect.x, -rect.y);\r\n\treturn el;\r\n}\r\n\r\nImageData.prototype.getPixel = function (x, y): [number, number, number, number] {\r\n\tvar i = x * 4 + y * 4 * this.width;\r\n\treturn [this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]];\r\n}\r\n\r\nImageData.prototype.getPixelValueSum = function (x, y) {\r\n\tvar i = x * 4 + y * 4 * this.width;\r\n\treturn this.data[i] + this.data[i + 1] + this.data[i + 2];\r\n}\r\n\r\nImageData.prototype.getPixelInt = function (x, y) {\r\n\tvar i = x * 4 + y * 4 * this.width;\r\n\treturn (this.data[i + 3] << 24) + (this.data[i + 0] << 16) + (this.data[i + 1] << 8) + (this.data[i + 2] << 0);\r\n}\r\n\r\nImageData.prototype.getColorDifference = function (x, y, r, g, b, a = 255) {\r\n\tvar i = x * 4 + y * 4 * this.width;\r\n\treturn Math.abs(this.data[i] - r) + Math.abs(this.data[i + 1] - g) + Math.abs(this.data[i + 2] - b) * a / 255;\r\n}\r\n\r\nImageData.prototype.setPixel = function (x, y, ...color) {\r\n\tvar r, g, b, a;\r\n\tvar [r, g, b, a] = (Array.isArray(color[0]) ? color[0] : color);\r\n\tvar i = x * 4 + y * 4 * this.width;\r\n\tthis.data[i] = r;\r\n\tthis.data[i + 1] = g;\r\n\tthis.data[i + 2] = b;\r\n\tthis.data[i + 3] = a == undefined ? 255 : a;\r\n}\r\n\r\nImageData.prototype.setPixelInt = function (x, y, color) {\r\n\tvar i = x * 4 + y * 4 * this.width;\r\n\tthis.data[i] = (color >> 24) & 0xff;\r\n\tthis.data[i + 1] = (color >> 16) & 0xff;\r\n\tthis.data[i + 2] = (color >> 8) & 0xff;\r\n\tthis.data[i + 3] = (color >> 0) & 0xff;\r\n}\r\n\r\nImageData.prototype.toFileBytes = function (this: ImageData, format: \"image/png\" | \"image/webp\", quality?: any) {\r\n\tif (typeof HTMLCanvasElement != \"undefined\") {\r\n\t\treturn new Promise<ArrayBuffer>(d => this.toImage().toBlob(b => {\r\n\t\t\tvar r = new FileReader();\r\n\t\t\tr.readAsArrayBuffer(b!);\r\n\t\t\tr.onload = () => d(new Uint8Array(r.result as ArrayBuffer));\r\n\t\t}, format, quality));\r\n\t} else {\r\n\t\treturn nodeimports.imageDataToFileBytes(this, format, quality);\r\n\t}\r\n}\r\n\r\nImageData.prototype.toPngBase64 = function (this: ImageData) {\r\n\tif (typeof HTMLCanvasElement != \"undefined\") {\r\n\t\tvar str = this.toImage().toDataURL(\"image/png\");\r\n\t\treturn str.slice(str.indexOf(\",\") + 1);\r\n\t} else {\r\n\t\tthrow new Error(\"synchronous image conversion not supported in nodejs, try using ImageData.prototype.toFileBytes\");\r\n\t}\r\n}\r\n\r\nImageData.prototype.pixelCompare = function (buf: ImageData, x = 0, y = 0, max?: number) {\r\n\treturn a1lib.ImageDetect.simpleCompare(this, buf, x, y, max);\r\n}\r\n\r\nImageData.prototype.copyTo = function (target: ImageData, sourcex: number, sourcey: number, width: number, height: number, targetx: number, targety: number) {\r\n\t//convince v8 that these are 31bit uints\r\n\tconst targetwidth = target.width | 0;\r\n\tconst thiswidth = this.width | 0;\r\n\r\n\tconst copywidth = width | 0;\r\n\tconst fastwidth = Math.floor(width / 4) * 4;\r\n\tconst thisdata = new Int32Array(this.data.buffer, this.data.byteOffset, this.data.byteLength / 4);\r\n\tconst targetdata = new Int32Array(target.data.buffer, target.data.byteOffset, target.data.byteLength / 4);\r\n\tfor (let cy = 0; cy < height; cy++) {\r\n\t\tlet cx = 0;\r\n\t\tlet it = (cx + targetx) + (cy + targety) * targetwidth;\r\n\t\tlet is = (cx + sourcex) + (cy + sourcey) * thiswidth;\r\n\t\t//copy 4 pixels per iter (xmm)\r\n\t\tfor (; cx < fastwidth; cx += 4) {\r\n\t\t\ttargetdata[it] = thisdata[is];\r\n\t\t\ttargetdata[it + 1] = thisdata[is + 1];\r\n\t\t\ttargetdata[it + 2] = thisdata[is + 2];\r\n\t\t\ttargetdata[it + 3] = thisdata[is + 3];\r\n\t\t\tit += 4;\r\n\t\t\tis += 4;\r\n\t\t}\r\n\t\t//copy remainder per pixel\r\n\t\tfor (; cx < copywidth; cx++) {\r\n\t\t\ttargetdata[it] = thisdata[is];\r\n\t\t\tit += 1;\r\n\t\t\tis += 1;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nif (typeof HTMLImageElement != \"undefined\") {\r\n\tHTMLImageElement.prototype.toBuffer = function (this: HTMLImageElement, x = 0, y = 0, w = this.width, h = this.height) {\r\n\t\tvar cnv = document.createElement(\"canvas\");\r\n\t\tcnv.width = w;\r\n\t\tcnv.height = h;\r\n\t\tvar ctx = cnv.getContext(\"2d\")!;\r\n\t\tctx.drawImage(this, -x, -y);\r\n\t\treturn ctx.getImageData(0, 0, w, h);\r\n\t}\r\n\r\n\tHTMLImageElement.prototype.toCanvas = function (this: HTMLImageElement, x = 0, y = 0, w = this.width, h = this.height) {\r\n\t\tvar cnv = document.createElement(\"canvas\");\r\n\t\tcnv.width = w;\r\n\t\tcnv.height = h;\r\n\t\tvar ctx = cnv.getContext(\"2d\")!;\r\n\t\tctx.drawImage(this, -x, -y);\r\n\t\treturn cnv;\r\n\t}\r\n}","//nodejs and electron polyfills for web api's\r\n//commented out type info as that breaks webpack with optional dependencies\r\n\r\nimport { ImageData } from \"./index\";\r\nimport { clearPngColorspace } from \"./imagedetect\";\r\n\r\nvar requirefunction: null | ((mod: string) => any) = null;\r\n\r\n/**\r\n * Call this function to let the libs require extra dependencies on nodejs in order\r\n * to polyfill some browser api's (mostly image compression/decompression)\r\n * `NodePolifill.polyfillRequire(require);` should solve most cases\r\n */\r\nexport function polyfillRequire(requirefn: (mod: string) => any) {\r\n\trequirefunction = requirefn;\r\n}\r\n\r\nexport function requireSharp() {\r\n\ttry {\r\n\t\tif (requirefunction) {\r\n\t\t\treturn requirefunction(\"sharp\");\r\n\t\t} else {\r\n\t\t\treturn require(/* webpackIgnore: true */ \"sharp\");// as typeof import(\"sharp\");\r\n\t\t}\r\n\t} catch (e) { }\r\n\treturn null;\r\n}\r\n\r\nexport function requireNodeCanvas() {\r\n\t//attempt to require sharp first, after loading canvas the module sharp fails to load\r\n\trequireSharp();\r\n\ttry {\r\n\t\tif (requirefunction) {\r\n\t\t\treturn requirefunction(\"canvas\");\r\n\t\t} else {\r\n\t\t\treturn require(/* webpackIgnore: true */ \"canvas\");// as typeof import(\"sharp\");\r\n\t\t}\r\n\t} catch (e) { }\r\n\treturn null;\r\n}\r\n\r\nexport function requireElectronCommon() {\r\n\ttry {\r\n\t\tif (requirefunction) {\r\n\t\t\treturn requirefunction(\"electron/common\");\r\n\t\t} else {\r\n\t\t\treturn require(/* webpackIgnore: true */ \"electron/common\");\r\n\t\t}\r\n\t} catch (e) { }\r\n\treturn null;\r\n}\r\n\r\nexport function imageDataToDrawable(buf: ImageData) {\r\n\tlet nodecnv = requireNodeCanvas();\r\n\tif (!nodecnv) { throw new Error(\"couldn't find built-in canvas or the module 'canvas'\"); }\r\n\treturn new nodecnv.ImageData(buf.data, buf.width, buf.height);\r\n}\r\n\r\nexport function createCanvas(w: number, h: number) {\r\n\tlet nodecnv = requireNodeCanvas();\r\n\tif (!nodecnv) { throw new Error(\"couldn't find built-in canvas or the module 'canvas'\"); }\r\n\treturn nodecnv.createCanvas(w, h) as any as HTMLCanvasElement;\r\n}\r\n\r\nfunction flipBGRAtoRGBA(data: Uint8ClampedArray | Uint8Array) {\r\n\tfor (let i = 0; i < data.length; i += 4) {\r\n\t\tlet tmp = data[i + 2];\r\n\t\tdata[i + 2] = data[i + 0];\r\n\t\tdata[i + 0] = tmp;\r\n\t}\r\n}\r\n\r\nexport async function imageDataToFileBytes(buf: ImageData, format: \"image/png\" | \"image/webp\", quality?: any) {\r\n\t//use the electron API if we're in electron\r\n\tvar electronCommon: any;\r\n\tvar sharp: any;\r\n\tif (electronCommon = requireElectronCommon()) {\r\n\t\tlet nativeImage = electronCommon.nativeImage;\r\n\t\t//need to copy the buffer in order to flip it without destroying the original\r\n\t\tlet bufcpy = Buffer.from(buf.data.slice(buf.data.byteOffset, buf.data.byteLength));\r\n\t\tflipBGRAtoRGBA(bufcpy);\r\n\t\tlet nativeimg = nativeImage.createFromBitmap(bufcpy, { width: buf.width, height: buf.height });\r\n\t\treturn nativeimg.toPNG();\r\n\t}\r\n\telse if (sharp = requireSharp()) {\r\n\t\tlet img = sharp(Buffer.from(buf.data.buffer), { raw: { width: buf.width, height: buf.height, channels: 4 } });\r\n\t\tif (format == \"image/png\") { img.png(); }\r\n\t\telse if (format == \"image/webp\") {\r\n\t\t\tvar opts = { quality: 80 };\r\n\t\t\tif (typeof quality == \"number\") { opts.quality = quality * 100; }\r\n\t\t\timg.webp(opts)\r\n\t\t}\r\n\t\telse { throw new Error(\"unknown image format: \" + format); }\r\n\t\treturn await img.toBuffer({ resolveWithObject: false }).buffer;\r\n\t}\r\n\tthrow new Error(\"coulnd't find build-in image compression methods or the module 'electron/common' or 'sharp'\");\r\n}\r\n\r\nexport function imageDataFromBase64(base64: string) {\r\n\treturn imageDataFromBuffer(Buffer.from(base64, \"base64\"));\r\n}\r\n\r\nexport async function imageDataFromBuffer(buffer: Uint8Array) {\r\n\tclearPngColorspace(buffer);\r\n\t//use the electron API if we're in electron\r\n\tvar electronCommon: any;\r\n\tvar nodecnv: any;\r\n\tif (electronCommon = requireElectronCommon()) {\r\n\t\tlet nativeImage = electronCommon.nativeImage;\r\n\t\tlet img = nativeImage.createFromBuffer(buffer);\r\n\t\tlet pixels = img.toBitmap();\r\n\t\tlet size = img.getSize();\r\n\t\tlet pixbuf = new Uint8ClampedArray(pixels.buffer, pixels.byteOffset, pixels.byteLength);\r\n\t\tflipBGRAtoRGBA(pixbuf);\r\n\t\treturn new ImageData(pixbuf, size.width, size.height);\r\n\t} else if (nodecnv = requireNodeCanvas()) {\r\n\t\treturn new Promise<ImageData>((done, err) => {\r\n\t\t\tlet img = new nodecnv.Image();\r\n\t\t\timg.onerror = err;\r\n\t\t\timg.onload = () => {\r\n\t\t\t\tvar cnv = nodecnv.createCanvas(img.naturalWidth, img.naturalHeight);\r\n\t\t\t\tvar ctx = cnv.getContext(\"2d\")!;\r\n\t\t\t\tctx.drawImage(img, 0, 0);\r\n\t\t\t\tvar data = ctx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);\r\n\t\t\t\t//use our own class\r\n\t\t\t\tdone(new ImageData(data.data, data.width, data.height));\r\n\t\t\t}\r\n\t\t\timg.src = Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n\t\t});\r\n\t}\r\n\tthrow new Error(\"couldn't find built-in canvas, module 'electron/common' or the module 'canvas'\");\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import * as ImageDetect from \"./imagedetect\";\r\nimport Rect, { RectLike } from \"./rect\";\r\nimport { ImgRefBind, ImgRefCtx, ImgRefData, ImgRef } from \"./imgref\";\r\nimport { ImageData } from \"./imagedata-extensions\";\r\nimport \"./alt1api\";\r\n\r\ndeclare global {\r\n\tnamespace alt1 {\r\n\t\tvar events: { [event: string]: Alt1EventHandler[] };\r\n\r\n\t\t//extension api\r\n\t\tvar capture: undefined | ((x: number, y: number, w: number, h: number) => Uint8ClampedArray);\r\n\t\tvar captureAsync: undefined | ((x: number, y: number, w: number, h: number) => Promise<Uint8ClampedArray>);\r\n\t\tvar captureMultiAsync: undefined | (<T extends { [id: string]: RectLike | null | undefined }>(areas: T) => Promise<{ [key in keyof T]: Uint8ClampedArray }>);\r\n\t\tvar bindGetRegionBuffer: undefined | ((id: number, x: number, y: number, width: number, height: number) => Uint8ClampedArray)\r\n\t}\r\n}\r\n\r\n/**\r\n * Thrown when a method is called that can not be used outside of Alt1\r\n */\r\nexport class NoAlt1Error extends Error {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.message = \"This method can not be ran outside of Alt1\";\r\n\t}\r\n};\r\n/**\r\n * Thrown when the Alt1 API returns an invalid result\r\n * Errors of a different type are throw when internal Alt1 errors occur\r\n */\r\nexport class Alt1Error extends Error { }\r\n\r\n/**\r\n * The latest Alt1 version\r\n */\r\nexport var newestversion = \"1.5.5\";\r\n\r\n/**\r\n * Whether the Alt1 API is available\r\n */\r\nexport var hasAlt1 = (typeof alt1 != \"undefined\");\r\n\r\n/**\r\n * The name of the Alt1 interface skin. (Always \"default\" if running in a browser)\r\n */\r\nexport var skinName = hasAlt1 ? alt1.skinName : \"default\";\r\n\r\n/**\r\n * Max number of bytes that can be sent by alt1 in one function\r\n * Not completely sure why this number is different than window.alt1.maxtranfer\r\n */\r\nvar maxtransfer = 4000000;\r\n\r\n/**\r\n * Open a link in the default browser\r\n * @deprecated use window.open instead\r\n */\r\nexport function openbrowser(url: string) {\r\n\tif (hasAlt1) {\r\n\t\talt1.openBrowser(url);\r\n\t}\r\n\telse {\r\n\t\twindow.open(url, '_blank');\r\n\t}\r\n}\r\n\r\n/**\r\n * Throw if Alt1 API is not available\r\n */\r\nexport function requireAlt1() {\r\n\tif (!hasAlt1) { throw new NoAlt1Error(); }\r\n}\r\n\r\n/**\r\n * Returns an object with a rectangle that spans all screens\r\n */\r\nexport function getdisplaybounds() {\r\n\tif (!hasAlt1) { return false; }\r\n\treturn new Rect(alt1.screenX, alt1.screenY, alt1.screenWidth, alt1.screenHeight);\r\n}\r\n\r\n/**\r\n * gets an imagebuffer with pixel data about the requested region\r\n */\r\nexport function capture(...args: [rect: RectLike] | [x: number, y: number, w: number, h: number]) {\r\n\t//TODO change null return on error into throw instead (x3)\r\n\tif (!hasAlt1) { throw new NoAlt1Error(); }\r\n\tvar rect = Rect.fromArgs(...args);\r\n\r\n\tif (alt1.capture) {\r\n\t\treturn new ImageData(alt1.capture(rect.x, rect.y, rect.width, rect.height), rect.width, rect.height);\r\n\t}\r\n\tvar buf = new ImageData(rect.width, rect.height);\r\n\r\n\tif (rect.width * rect.height * 4 <= maxtransfer) {\r\n\t\tvar data = alt1.getRegion(rect.x, rect.y, rect.width, rect.height);\r\n\t\tif (!data) { return null!; }\r\n\t\tdecodeImageString(data, buf, 0, 0, rect.width, rect.height);\r\n\t}\r\n\telse {\r\n\t\t//split up the request to to exceed the single transfer limit (for now)\r\n\t\tvar x1 = rect.x;\r\n\t\tvar ref = alt1.bindRegion(rect.x, rect.y, rect.width, rect.height);\r\n\t\tif (ref <= 0) { return null!; }\r\n\t\twhile (x1 < rect.x + rect.width) {\r\n\t\t\tvar x2 = Math.min(rect.x + rect.width, Math.floor(x1 + (maxtransfer / 4 / rect.height)));\r\n\t\t\tvar data = alt1.bindGetRegion(ref, x1, rect.y, x2 - x1, rect.height);\r\n\t\t\tif (!data) { return null!; }\r\n\t\t\tdecodeImageString(data, buf, x1 - rect.x, 0, x2 - x1, rect.height);\r\n\t\t\tx1 = x2;\r\n\t\t}\r\n\t}\r\n\treturn buf;\r\n}\r\n\r\n/**\r\n * Makes alt1 bind an area of the rs client in memory without sending it to the js client\r\n * returns an imgref object which can be used to get pixel data using the imgreftobuf function\r\n * currently only one bind can exist per app and the ref in (v) will always be 1\r\n */\r\nexport function captureHold(x: number, y: number, w: number, h: number) {\r\n\tx = Math.round(x); y = Math.round(y); w = Math.round(w); h = Math.round(h);\r\n\trequireAlt1();\r\n\tvar r = alt1.bindRegion(x, y, w, h);\r\n\tif (r <= 0) { throw new Alt1Error(\"capturehold failed\"); }\r\n\treturn new ImgRefBind(r, x, y, w, h);\r\n}\r\n\r\n/**\r\n * Same as captureHoldRegion, but captures the screen instead of the rs client. it also uses screen coordinates instead and can capture outside of the rs client\r\n */\r\nexport function captureHoldScreen(x: number, y: number, w: number, h: number) {\r\n\tx = Math.round(x); y = Math.round(y); w = Math.round(w); h = Math.round(h);\r\n\trequireAlt1();\r\n\tvar r = alt1.bindScreenRegion(x, y, w, h);\r\n\tif (r <= 0) { return false; }\r\n\treturn new ImgRefBind(r, x, y, w, h);\r\n}\r\n\r\n/**\r\n * bind the full rs window if the rs window can be detected by alt1, otherwise return the full screen\r\n */\r\nexport function captureHoldFullRs() {\r\n\treturn captureHold(0, 0, alt1.rsWidth, alt1.rsHeight);\r\n}\r\n\r\n/**\r\n * returns a subregion from a bound image\r\n * used internally in imgreftobuf if imgref is a bound image\r\n * @deprecated This should be handled internall by the imgrefbind.toData method\r\n */\r\nexport function transferImageData(handle: number, x: number, y: number, w: number, h: number) {\r\n\tx = Math.round(x); y = Math.round(y); w = Math.round(w); h = Math.round(h);\r\n\trequireAlt1();\r\n\r\n\tif (alt1.bindGetRegionBuffer) {\r\n\t\treturn new ImageData(alt1.bindGetRegionBuffer(handle, x, y, w, h), w, h);\r\n\t}\r\n\tvar r = new ImageData(w, h);\r\n\r\n\tvar x1 = x;\r\n\twhile (true) {//split up the request to to exceed the single transfer limit (for now)\r\n\t\tvar x2 = Math.min(x + w, Math.floor(x1 + (maxtransfer / 4 / h)));\r\n\t\tvar a = alt1.bindGetRegion(handle, x1, y, x2 - x1, h);\r\n\t\tif (!a) { throw new Alt1Error(); }\r\n\t\tdecodeImageString(a, r, x1 - x, 0, x2 - x1, h);\r\n\t\tx1 = x2;\r\n\t\tif (x1 == x + w) { break; };\r\n\t}\r\n\treturn r;\r\n}\r\n\r\n/**\r\n * decodes a returned string from alt1 to an imagebuffer\r\n */\r\nexport function decodeImageString(imagestring: string, target: ImageData, x: number, y: number, w: number, h: number) {\r\n\tvar bin = atob(imagestring);\r\n\r\n\tvar bytes = target.data;\r\n\r\n\tw |= 0;\r\n\th |= 0;\r\n\tvar offset = 4 * x + 4 * y * target.width;\r\n\tvar target_width = target.width | 0;\r\n\tfor (var a = 0; a < w; a++) {\r\n\t\tfor (var b = 0; b < h; b++) {\r\n\t\t\tvar i1 = (offset + (a * 4 | 0) + (b * target_width * 4 | 0)) | 0;\r\n\t\t\tvar i2 = ((a * 4 | 0) + (b * 4 * w | 0)) | 0;\r\n\t\t\tbytes[i1 + 0 | 0] = bin.charCodeAt(i2 + 2 | 0);//fix weird red/blue swap in c#\r\n\t\t\tbytes[i1 + 1 | 0] = bin.charCodeAt(i2 + 1 | 0);\r\n\t\t\tbytes[i1 + 2 | 0] = bin.charCodeAt(i2 + 0 | 0);\r\n\t\t\tbytes[i1 + 3 | 0] = bin.charCodeAt(i2 + 3 | 0);\r\n\t\t}\r\n\t}\r\n\treturn target;\r\n}\r\n\r\n/**\r\n * encodes an imagebuffer to a string\r\n */\r\nexport function encodeImageString(buf: ImageData, sx = 0, sy = 0, sw = buf.width, sh = buf.height) {\r\n\tvar raw = \"\";\r\n\tfor (var y = sy; y < sy + sh; y++) {\r\n\t\tfor (var x = sx; x < sx + sw; x++) {\r\n\t\t\tvar i = 4 * x + 4 * buf.width * y | 0;\r\n\t\t\traw += String.fromCharCode(buf.data[i + 2 | 0]);\r\n\t\t\traw += String.fromCharCode(buf.data[i + 1 | 0]);\r\n\t\t\traw += String.fromCharCode(buf.data[i + 0 | 0]);\r\n\t\t\traw += String.fromCharCode(buf.data[i + 3 | 0]);\r\n\t\t}\r\n\t}\r\n\treturn btoa(raw);\r\n}\r\n\r\n/**\r\n * mixes the given color into a single int. This format is used by alt1\r\n */\r\nexport function mixColor(r: number, g: number, b: number, a = 255) {\r\n\treturn (b << 0) + (g << 8) + (r << 16) + (a << 24);\r\n}\r\n\r\nexport function unmixColor(col: number): [number, number, number] {\r\n\tvar r = (col >> 16) & 0xff;\r\n\tvar g = (col >> 8) & 0xff;\r\n\tvar b = (col >> 0) & 0xff;\r\n\treturn [r, g, b];\r\n}\r\n\r\nexport function identifyApp(url: string) {\r\n\tif (hasAlt1) { alt1.identifyAppUrl(url); }\r\n}\r\n\r\nexport function resetEnvironment() {\r\n\thasAlt1 = (typeof alt1 != \"undefined\");\r\n\tskinName = hasAlt1 ? alt1.skinName : \"default\";\r\n}\r\n\r\nfunction convertAlt1Version(str: string) {\r\n\tvar a = str.match(/^(\\d+)\\.(\\d+)\\.(\\d+)$/);\r\n\tif (!a) { throw new RangeError(\"Invalid version string\"); }\r\n\treturn (+a[1]) * 1000 * 1000 + (+a[2]) * 1000 + (+a[3]) * 1;\r\n}\r\n\r\nvar cachedVersionInt = -1\r\n/**\r\n * checks if alt1 is running and at least the given version. versionstr should be a string with the version eg: 1.3.2\r\n * @param versionstr\r\n */\r\nexport function hasAlt1Version(versionstr: string) {\r\n\tif (!hasAlt1) { return false; }\r\n\tif (cachedVersionInt == -1) { cachedVersionInt = alt1.versionint; }\r\n\treturn cachedVersionInt >= convertAlt1Version(versionstr);\r\n}\r\n\r\n/**\r\n * Gets the current cursor position in the game, returns null if the rs window is not active (alt1.rsActive)\r\n */\r\nexport function getMousePosition() {\r\n\tvar pos = alt1.mousePosition;\r\n\tif (pos == -1) { return null; }\r\n\treturn { x: pos >>> 16, y: pos & 0xFFFF };\r\n}\r\n/**\r\n * Registers a given HTML element as a frame border, when this element is dragged by the user the Alt1 frame will resize accordingly\r\n * Use the direction arguements to make a given direction stick to the mouse. eg. Only set left to true to make the element behave as the left border\r\n * Or set all to true to move the whole window. Not all combinations are permitted\r\n */\r\nexport function addResizeElement(el: HTMLElement, left: boolean, top: boolean, right: boolean, bot: boolean) {\r\n\tif (!hasAlt1 || !alt1.userResize) { return; }\r\n\tel.addEventListener(\"mousedown\", function (e) {\r\n\t\talt1.userResize(left, top, right, bot);\r\n\t\te.preventDefault();\r\n\t});\r\n}\r\n\r\n\r\n\r\nexport type Alt1EventHandler = (e: any) => void;\r\n\r\n/**\r\n * Add an event listener\r\n */\r\nexport function on<K extends keyof Alt1EventType>(type: K, listener: (ev: Alt1EventType[K]) => void) {\r\n\tif (!hasAlt1) { return; }\r\n\tif (!alt1.events) { alt1.events = {}; }\r\n\tif (!alt1.events[type]) { alt1.events[type] = []; }\r\n\talt1.events[type].push(listener);\r\n}\r\n\r\n/**\r\n * Removes an event listener\r\n */\r\nexport function removeListener<K extends keyof Alt1EventType>(type: K, listener: (ev: Alt1EventType[K]) => void) {\r\n\tvar elist = hasAlt1 && alt1.events && alt1.events[type];\r\n\tif (!elist) { return; }\r\n\tvar i = elist.indexOf(listener);\r\n\tif (i == -1) { return; }\r\n\telist.splice(i, 1);\r\n}\r\n\r\n/**\r\n * Listens for the event to fire once and then stops listening\r\n * @param event\r\n * @param cb\r\n */\r\nexport function once<K extends keyof Alt1EventType>(type: K, listener: (ev: Alt1EventType[K]) => void) {\r\n\tvar fn = (e: Alt1EventType[K]) => {\r\n\t\tremoveListener(type, fn);\r\n\t\tlistener(e);\r\n\t};\r\n\ton(type, fn);\r\n}\r\nexport interface Alt1EventType {\r\n\t\"alt1pressed\": { eventName: \"alt1pressed\", text: string, mouseAbs: { x: number, y: number }, mouseRs: { x: number, y: number }, x: number, y: number, rsLinked: boolean },\r\n\t\"menudetected\": { eventName: \"menudetected\", rectangle: { x: number, y: number, width: number, height: number } },\r\n\t\"rslinked\": { eventName: \"rslinked\" },\r\n\t\"rsunlinked\": { eventName: \"rsunlinked\" },\r\n\t\"permissionchanged\": { eventName: \"permissionchanged\" },\r\n\t\"daemonrun\": { eventName: \"daemonrun\", result: { now: number, nextRun: number, state: string, messages: { [id: string]: { title: string, body: string } }, statusXml: string } },\r\n\t\"userevent\": { eventName: \"userevent\", argument: string },\r\n\t\"rsfocus\": { eventName: \"rsfocus\" },\r\n\t\"rsblur\": { eventName: \"rsblur\" },\r\n};\r\n\r\n/**\r\n * Used to read a set of images from a binary stream returned by the Alt1 API\r\n */\r\nexport class ImageStreamReader {\r\n\tprivate framebuffer: ImageData | null = null;\r\n\tprivate streamreader: ReadableStreamReader<Uint8Array>;\r\n\tprivate pos = 0;\r\n\tprivate reading = false;\r\n\tclosed = false;\r\n\r\n\t//paused state\r\n\tprivate pausedindex = -1;\r\n\tprivate pausedbuffer: Uint8Array | null = null;\r\n\r\n\tconstructor(reader: ReadableStreamReader<Uint8Array>, width: number, height: number);\r\n\tconstructor(reader: ReadableStreamReader<Uint8Array>, framebuffer: ImageData);\r\n\tconstructor(reader: ReadableStreamReader<Uint8Array>);\r\n\tconstructor(reader: ReadableStreamReader<Uint8Array>, ...args: any[]) {\r\n\t\tthis.streamreader = reader;\r\n\t\tif (args[0] instanceof ImageData) { this.setFrameBuffer(args[0]); }\r\n\t\telse if (typeof args[0] == \"number\") { this.setFrameBuffer(new ImageData(args[0], args[1])); }\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tsetFrameBuffer(buffer: ImageData) {\r\n\t\tif (this.reading) { throw new Error(\"can't change framebuffer while reading\"); }\r\n\t\tthis.framebuffer = buffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Closes the underlying stream and ends reading\r\n\t */\r\n\tclose() {\r\n\t\tthis.streamreader.cancel();\r\n\t}\r\n\r\n\t/**\r\n\t * Reads a single image from the stream\r\n\t */\r\n\tasync nextImage() {\r\n\t\tif (this.reading) { throw new Error(\"already reading from this stream\"); }\r\n\t\tif (!this.framebuffer) { throw new Error(\"framebuffer not set\"); }\r\n\t\tthis.reading = true;\r\n\t\tvar synctime = -Date.now();\r\n\t\tvar starttime = Date.now();\r\n\t\tvar r = false;\r\n\t\twhile (!r) {\r\n\t\t\tif (this.pausedindex != -1 && this.pausedbuffer) {\r\n\t\t\t\tr = this.readChunk(this.pausedindex, this.framebuffer.data, this.pausedbuffer);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tsynctime += Date.now();\r\n\t\t\t\tvar res = await this.streamreader.read();\r\n\t\t\t\tsynctime -= Date.now();\r\n\t\t\t\tif (res.done) { throw new Error(\"Stream closed while reading\"); }\r\n\t\t\t\tvar data = res.value;\r\n\t\t\t\tr = this.readChunk(0, this.framebuffer.data, data);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsynctime += Date.now();\r\n\t\t//console.log(\"Decoded async image, \" + this.framebuffer.width + \"x\" + this.framebuffer.height + \" time: \" + (Date.now() - starttime) + \"ms (\" + synctime + \"ms main thread)\");\r\n\t\tthis.reading = false;\r\n\t\treturn this.framebuffer;\r\n\t}\r\n\r\n\tprivate readChunk(i: number, framedata: Uint8ClampedArray, buffer: Uint8Array) {\r\n\t\t//very hot code, explicit int32 casting with |0 speeds it up by ~ x2\r\n\t\ti = i | 0;\r\n\t\tvar framesize = framedata.length | 0;\r\n\t\tvar pos = this.pos;\r\n\t\tvar datalen = buffer.length | 0;\r\n\t\t//var data32 = new Float64Array(buffer.buffer);\r\n\t\t//var framedata32 = new Float64Array(framedata.buffer);\r\n\r\n\t\t//fix possible buffer misalignment\r\n\t\t//align to 16 for extra loop unrolling\r\n\t\twhile (i < datalen) {\r\n\t\t\t//slow loop, fix alignment and other issues\r\n\t\t\twhile (i < datalen && pos < framesize && (pos % 16 != 0 || !((i + 16 | 0) <= datalen && (pos + 16 | 0) <= framesize))) {\r\n\t\t\t\tvar rel = pos;\r\n\t\t\t\tif (pos % 4 == 0) { rel = rel + 2 | 0; }\r\n\t\t\t\tif (pos % 4 == 2) { rel = rel - 2 | 0; }\r\n\t\t\t\tframedata[rel | 0] = buffer[i | 0];\r\n\t\t\t\ti = i + 1 | 0;\r\n\t\t\t\tpos = pos + 1 | 0;\r\n\t\t\t}\r\n\r\n\t\t\t//fast unrolled loop for large chunks i wish js had some sort of memcpy\r\n\t\t\tif (pos % 16 == 0) {\r\n\t\t\t\twhile ((i + 16 | 0) <= datalen && (pos + 16 | 0) <= framesize) {\r\n\t\t\t\t\tframedata[pos + 0 | 0] = buffer[i + 2 | 0];\r\n\t\t\t\t\tframedata[pos + 1 | 0] = buffer[i + 1 | 0];\r\n\t\t\t\t\tframedata[pos + 2 | 0] = buffer[i + 0 | 0];\r\n\t\t\t\t\tframedata[pos + 3 | 0] = buffer[i + 3 | 0];\r\n\r\n\t\t\t\t\tframedata[pos + 4 | 0] = buffer[i + 6 | 0];\r\n\t\t\t\t\tframedata[pos + 5 | 0] = buffer[i + 5 | 0];\r\n\t\t\t\t\tframedata[pos + 6 | 0] = buffer[i + 4 | 0];\r\n\t\t\t\t\tframedata[pos + 7 | 0] = buffer[i + 7 | 0];\r\n\r\n\t\t\t\t\tframedata[pos + 8 | 0] = buffer[i + 10 | 0];\r\n\t\t\t\t\tframedata[pos + 9 | 0] = buffer[i + 9 | 0];\r\n\t\t\t\t\tframedata[pos + 10 | 0] = buffer[i + 8 | 0];\r\n\t\t\t\t\tframedata[pos + 11 | 0] = buffer[i + 11 | 0];\r\n\r\n\t\t\t\t\tframedata[pos + 12 | 0] = buffer[i + 14 | 0];\r\n\t\t\t\t\tframedata[pos + 13 | 0] = buffer[i + 13 | 0];\r\n\t\t\t\t\tframedata[pos + 14 | 0] = buffer[i + 12 | 0];\r\n\t\t\t\t\tframedata[pos + 15 | 0] = buffer[i + 15 | 0];\r\n\r\n\t\t\t\t\t//could speed it up another x2 but wouldn't be able to swap r/b swap and possible alignment issues\r\n\t\t\t\t\t//framedata32[pos / 8 + 0 | 0] = data32[i / 8 + 0 | 0];\r\n\t\t\t\t\t//framedata32[pos / 8 + 1 | 0] = data32[i / 8 + 1 | 0];\r\n\t\t\t\t\t//framedata32[pos / 4 + 2 | 0] = data32[i / 4 + 2 | 0];\r\n\t\t\t\t\t//framedata32[pos / 4 + 3 | 0] = data32[i / 4 + 3 | 0];\r\n\r\n\t\t\t\t\tpos = pos + 16 | 0;\r\n\t\t\t\t\ti = i + 16 | 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (pos >= framesize) {\r\n\t\t\t\tthis.pausedbuffer = null;\r\n\t\t\t\tthis.pausedindex = -1;\r\n\r\n\t\t\t\tthis.pos = 0;\r\n\t\t\t\tif (i != buffer.length - 1) {\r\n\t\t\t\t\tthis.pausedbuffer = buffer;\r\n\t\t\t\t\tthis.pausedindex = i;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.pos = pos;\r\n\t\tthis.pausedbuffer = null;\r\n\t\tthis.pausedindex = -1;\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Asynchronously captures a section of the game screen\r\n */\r\nexport async function captureAsync(...args: [rect: RectLike] | [x: number, y: number, width: number, height: number]) {\r\n\trequireAlt1();\r\n\tvar rect = Rect.fromArgs(...args);\r\n\tif (alt1.captureAsync) {\r\n\t\tlet img = await alt1.captureAsync(rect.x, rect.y, rect.width, rect.height);\r\n\t\treturn new ImageData(img, rect.width, rect.height);\r\n\t}\r\n\r\n\tif (!hasAlt1Version(\"1.4.6\")) {\r\n\t\treturn capture(rect.x, rect.y, rect.width, rect.height);\r\n\t}\r\n\tvar url = \"https://alt1api/pixel/getregion/\" + encodeURIComponent(JSON.stringify({ ...rect, format: \"raw\", quality: 1 }));\r\n\tvar res = await fetch(url);\r\n\tvar imgreader = new ImageStreamReader(res.body!.getReader(), rect.width, rect.height);\r\n\treturn imgreader.nextImage();\r\n}\r\n\r\n/**\r\n * Asynchronously captures multple area's. This method captures the images in the same render frame if possible\r\n * @param areas \r\n */\r\nexport async function captureMultiAsync<T extends { [id: string]: RectLike | null | undefined }>(areas: T) {\r\n\trequireAlt1();\r\n\tvar r = {} as { [K in keyof T]: ImageData | null };\r\n\tif (alt1.captureMultiAsync) {\r\n\t\tlet bufs = await alt1.captureMultiAsync(areas);\r\n\t\tfor (let a in areas) {\r\n\t\t\tif (!bufs[a]) { r[a] = null; }\r\n\t\t\tr[a] = new ImageData(bufs[a], areas[a]!.width, areas[a]!.height);\r\n\t\t}\r\n\t\treturn r;\r\n\t}\r\n\r\n\tvar capts = [] as RectLike[];\r\n\tvar captids = [] as (keyof T)[];\r\n\tfor (var id in areas) {\r\n\t\tif (areas[id]) { capts.push(areas[id]!); captids.push(id); }\r\n\t\telse { r[id] = null; }\r\n\t}\r\n\tif (capts.length == 0) { return r; }\r\n\tif (!hasAlt1Version(\"1.5.1\")) {\r\n\t\tvar proms = [] as Promise<ImageData | null>[];\r\n\t\tfor (var a = 0; a < capts.length; a++) { proms.push(captureAsync(capts[a])); }\r\n\t\tvar results = await Promise.all(proms);\r\n\t\tfor (var a = 0; a < capts.length; a++) { r[captids[a]] = results[a]; }\r\n\t} else {\r\n\t\tvar res = await fetch(\"https://alt1api/pixel/getregionmulti/\" + encodeURIComponent(JSON.stringify({ areas: capts, format: \"raw\", quality: 1 })));\r\n\t\tvar imgreader = new ImageStreamReader(res.body!.getReader());\r\n\t\tfor (var a = 0; a < capts.length; a++) {\r\n\t\t\tvar capt = capts[a];\r\n\t\t\timgreader.setFrameBuffer(new ImageData(capt.width, capt.height));\r\n\t\t\tr[captids[a]] = await imgreader.nextImage();\r\n\t\t}\r\n\t}\r\n\treturn r;\r\n}\r\n\r\nexport type CaptureStreamResult = { x: number, y: number, width: number, height: number, framenr: number, close: () => void, closed: boolean };\r\n\r\n/**\r\n * Starts capturing a realtime stream of the game. Make sure you keep reading the stream and close it when you're done or Alt1 WILL crash\r\n * @param framecb Called whenever a new frame is decoded\r\n * @param errorcb Called whenever an error occurs, the error is rethrown if not defined\r\n * @param fps Maximum fps of the stream\r\n */\r\nexport function captureStream(x: number, y: number, width: number, height: number, fps: number, framecb: (img: ImageData) => void, errorcb?: (e: Error) => void): CaptureStreamResult {\r\n\trequireAlt1();\r\n\tif (!hasAlt1Version(\"1.4.6\")) { throw new Alt1Error(\"This function is not supported in this version of Alt1\"); }\r\n\tvar url = \"https://alt1api/pixel/streamregion/\" + encodeURIComponent(JSON.stringify({ x, y, width, height, fps, format: \"raw\" }));\r\n\tvar res = fetch(url).then(async res => {\r\n\t\tvar reader = new ImageStreamReader(res.body!.getReader(), width, height);\r\n\t\ttry {\r\n\t\t\twhile (!reader.closed && !state.closed) {\r\n\t\t\t\tvar img = await reader.nextImage();\r\n\t\t\t\tif (!state.closed) {\r\n\t\t\t\t\tframecb(img);\r\n\t\t\t\t\tstate.framenr++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tif (!state.closed) {\r\n\t\t\t\treader.close();\r\n\t\t\t\tif (errorcb) { errorcb(e); }\r\n\t\t\t\telse { throw e; }\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!reader.closed && state.closed) {\r\n\t\t\treader.close();\r\n\t\t}\r\n\t});\r\n\tvar state = {\r\n\t\tx, y, width, height,\r\n\t\tframenr: 0,\r\n\t\tclose: () => { state.closed = true; },\r\n\t\tclosed: false,\r\n\t};\r\n\treturn state;\r\n}\r\n","import { ImgRef, ImgRefBind } from \"./imgref\";\r\nimport * as wapper from \"./wrapper\";\r\nimport * as nodeimports from \"./nodepolyfill\";\r\nimport { RectLike, Rect } from \".\";\r\n\r\n/**\r\n* Downloads an image and returns the ImageData\r\n* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!\r\n* @param url http(s) or data url to the image\r\n*/\r\nexport async function imageDataFromUrl(url: string): Promise<ImageData> {\r\n\tif (typeof Image != \"undefined\") {\r\n\t\tvar img = new Image();\r\n\t\timg.crossOrigin = \"crossorigin\";\r\n\t\treturn await new Promise((done, fail) => {\r\n\t\t\timg.onload = function () { done(img.toBuffer()); };\r\n\t\t\timg.onerror = fail;\r\n\t\t\timg.src = url;\r\n\t\t}) as ImageData;\r\n\t} else {\r\n\t\tvar hdr = \"data:image/png;base64,\";\r\n\t\tif (url.startsWith(hdr)) {\r\n\t\t\treturn imageDataFromBase64(url.slice(hdr.length));\r\n\t\t}\r\n\t\tthrow new Error(\"loading remote images in nodejs has been disabled, load the raw bytes and use imageDataFromNodeBuffer instead\");\r\n\t}\r\n}\r\n\r\n/**\r\n* Loads an ImageData object from a base64 encoded png image\r\n* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!\r\n* @param data a base64 encoded png image\r\n*/\r\nexport async function imageDataFromBase64(data: string) {\r\n\tif (typeof Image != \"undefined\") {\r\n\t\treturn imageDataFromUrl(\"data:image/png;base64,\" + data);\r\n\t} else {\r\n\t\treturn nodeimports.imageDataFromBase64(data);\r\n\t}\r\n}\r\n\r\n/**\r\n * Loads an ImageData object directly from a png encoded file buffer\r\n * This method ensures that png color space headers are taken care off\r\n * @param data The bytes of a png file\r\n */\r\nexport async function imageDataFromFileBuffer(data: Uint8Array) {\r\n\tclearPngColorspace(data);\r\n\tif (typeof Image != \"undefined\") {\r\n\t\tlet blob = new Blob([data], { type: \"image/png\" });\r\n\t\tlet url = URL.createObjectURL(blob);\r\n\t\tlet r = await imageDataFromUrl(url);\r\n\t\tURL.revokeObjectURL(url);\r\n\t\treturn r;\r\n\t} else {\r\n\t\treturn nodeimports.imageDataFromBuffer(data);\r\n\t}\r\n}\r\n\r\n/**\r\n* Checks if a given byte array is a png file (by checking for ?PNG as first 4 bytes)\r\n* @param bytes Raw bytes of the png file\r\n*/\r\nexport function isPngBuffer(bytes: Uint8Array) {\r\n\treturn bytes[0] == 137 && bytes[1] == 80 && bytes[2] == 78 && bytes[3] == 71;\r\n}\r\n/**\r\n* Resets the colorspace data in the png file.\r\n* This makes sure the browser renders the exact colors in the file instead of filtering it in order to obtain the best real life representation of\r\n* what it looked like on the authors screen. (this feature is often broken and not supported)\r\n* For example a round trip printscreen -> open in browser results in different colors than the original\r\n* @param data Raw bytes of the png file\r\n*/\r\nexport function clearPngColorspace(data: Uint8Array) {\r\n\tif (!isPngBuffer(data)) { throw new Error(\"non-png image received\"); }\r\n\tvar i = 8;\r\n\twhile (i < data.length) {\r\n\t\tvar length = data[i++] * 0x1000000 + data[i++] * 0x10000 + data[i++] * 0x100 + data[i++];\r\n\t\tvar ancillary = !!((data[i] >> 5) & 1);\r\n\t\tvar chunkname = String.fromCharCode(data[i], data[i + 1], data[i + 2], data[i + 3]);\r\n\t\tvar chunkid = chunkname.toLowerCase();\r\n\t\tif (chunkid != \"trns\" && ancillary) {\r\n\t\t\tdata[i + 0] = \"n\".charCodeAt(0);\r\n\t\t\tdata[i + 1] = \"o\".charCodeAt(0);\r\n\t\t\tdata[i + 2] = \"P\".charCodeAt(0);\r\n\t\t\tdata[i + 3] = \"E\".charCodeAt(0);\r\n\r\n\t\t\t//calculate new chunk checksum\r\n\t\t\t//http://www.libpng.org/pub/png/spec/1.2/PNG-CRCAppendix.html\r\n\t\t\tvar end = i + 4 + length;\r\n\t\t\tvar crc = 0xffffffff;\r\n\r\n\t\t\t//should be fast enough like this\r\n\t\t\tvar bitcrc = function (bit: number) {\r\n\t\t\t\tfor (var k = 0; k < 8; k++) {\r\n\t\t\t\t\tif (bit & 1) { bit = 0xedb88320 ^ (bit >>> 1); }\r\n\t\t\t\t\telse { bit = bit >>> 1; }\r\n\t\t\t\t}\r\n\t\t\t\treturn bit;\r\n\t\t\t}\r\n\t\t\tfor (var a = i; a < end; a++) {\r\n\t\t\t\tif (a >= i + 4) { data[a] = 0; }\r\n\t\t\t\tvar bit = data[a];\r\n\t\t\t\tcrc = bitcrc((crc ^ bit) & 0xff) ^ (crc >>> 8);\r\n\t\t\t}\r\n\t\t\tcrc = crc ^ 0xffffffff;\r\n\t\t\t//new chunk checksum\r\n\t\t\tdata[i + 4 + length + 0] = (crc >> 24) & 0xff;\r\n\t\t\tdata[i + 4 + length + 1] = (crc >> 16) & 0xff;\r\n\t\t\tdata[i + 4 + length + 2] = (crc >> 8) & 0xff;\r\n\t\t\tdata[i + 4 + length + 3] = (crc >> 0) & 0xff;\r\n\t\t}\r\n\t\tif (chunkname == \"IEND\") { break; }\r\n\t\ti += 4;//type\r\n\t\ti += length;//data\r\n\t\ti += 4;//crc\r\n\t}\r\n}\r\n\r\n/**\r\n* finds the given needle ImageBuffer in the given haystack ImgRef this function uses the best optimized available\r\n* code depending on the type of the haystack. It will use fast c# searching if the haystack is an ImgRefBind, js searching\r\n* is used otherwise.\r\n* the checklist argument is no longer used and should ignored or null/undefined\r\n* The optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search the needle. The rectangle should be bigger than the needle\r\n* @returns An array of points where the needle is found. The array is empty if none are found\r\n*/\r\nexport function findSubimage(haystackImgref: ImgRef, needleBuffer: ImageData, sx = 0, sy = 0, sw = haystackImgref.width, sh = haystackImgref.height) {\r\n\tif (!haystackImgref) { throw new TypeError(); }\r\n\tif (!needleBuffer) { throw new TypeError(); }\r\n\r\n\tvar max = 30;\r\n\r\n\t//check if we can do this in alt1\r\n\tif (haystackImgref instanceof ImgRefBind && wapper.hasAlt1 && alt1.bindFindSubImg) {\r\n\t\tvar needlestr = wapper.encodeImageString(needleBuffer);\r\n\t\tvar r = alt1.bindFindSubImg(haystackImgref.handle, needlestr, needleBuffer.width, sx, sy, sw, sh);\r\n\t\tif (!r) { throw new wapper.Alt1Error(); }\r\n\t\treturn JSON.parse(r) as { x: number, y: number }[];\r\n\t}\r\n\r\n\treturn findSubbuffer(haystackImgref.read(), needleBuffer, sx, sy, sw, sh);\r\n}\r\n\r\n/**\r\n* Uses js to find the given needle ImageBuffer in the given haystack ImageBuffer. It is better to use the alt1.bind- functions in\r\n* combination with a1nxt.findsubimg.\r\n* the optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search.\r\n* @returns An array of points where the needle is found. The array is empty if none are found\r\n*/\r\nexport function findSubbuffer(haystack: ImageData, needle: ImageData, sx = 0, sy = 0, sw = haystack.width, sh = haystack.height) {\r\n\tvar r: { x: number, y: number }[] = [];\r\n\tvar maxdif = 30;\r\n\tvar maxresults = 50;\r\n\tvar needlestride = needle.width * 4;\r\n\tvar heystackstride = haystack.width * 4;\r\n\r\n\t//built list of non trans pixel to check\r\n\tvar checkList: { x: number, y: number }[] = [];\r\n\tfor (var y = 0; y < needle.height; y++) {\r\n\t\tfor (var x = 0; x < needle.width; x++) {\r\n\t\t\tvar i = x * 4 + y * needlestride;\r\n\t\t\tif (needle.data[i + 3] == 255) { checkList.push({ x: x, y: y }); }\r\n\t\t\tif (checkList.length == 10) { break; }\r\n\t\t}\r\n\t\tif (checkList.length == 10) { break; }\r\n\t}\r\n\r\n\tvar cw = (sx + sw) - needle.width;\r\n\tvar ch = (sy + sh) - needle.height;\r\n\tvar checklength = checkList.length;\r\n\tfor (var y = sy; y <= ch; y++) {\r\n\t\touter: for (var x = sx; x <= cw; x++) {\r\n\t\t\tfor (var a = 0; a < checklength; a++) {\r\n\t\t\t\tvar i1 = (x + checkList[a].x) * 4 + (y + checkList[a].y) * heystackstride;\r\n\t\t\t\tvar i2 = checkList[a].x * 4 + checkList[a].y * needlestride;\r\n\r\n\t\t\t\tvar d = 0;\r\n\t\t\t\td = d + Math.abs(haystack.data[i1 + 0] - needle.data[i2 + 0]) | 0;\r\n\t\t\t\td = d + Math.abs(haystack.data[i1 + 1] - needle.data[i2 + 1]) | 0;\r\n\t\t\t\td = d + Math.abs(haystack.data[i1 + 2] - needle.data[i2 + 2]) | 0;\r\n\t\t\t\td *= 255 / needle.data[i2 + 3];\r\n\t\t\t\tif (d > maxdif) {\r\n\t\t\t\t\tcontinue outer;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (simpleCompare(haystack, needle, x, y, maxdif) != Infinity) {\r\n\t\t\t\tr.push({ x, y });\r\n\t\t\t\tif (r.length > maxresults) { return r; }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn r;\r\n}\r\n\r\n/**\r\n* Compares two images and returns the average color difference per pixel between them\r\n* @param max The max color difference at any point in the image before short circuiting the function and returning Infinity. set to -1 to always continue.\r\n* @returns The average color difference per pixel or Infinity if the difference is more than max at any point in the image\r\n*/\r\nexport function simpleCompare(bigbuf: ImageData, checkbuf: ImageData, x: number, y: number, max = 30) {\r\n\tif (x < 0 || y < 0) { throw new RangeError(); }\r\n\tif (x + checkbuf.width > bigbuf.width || y + checkbuf.height > bigbuf.height) { throw new RangeError(); }\r\n\r\n\tif (max == -1) { max = 255 * 4; }\r\n\r\n\tvar dif = 0;\r\n\tfor (var step = 8; step >= 1; step /= 2) {\r\n\t\tfor (var cx = 0; cx < checkbuf.width; cx += step) {\r\n\t\t\tfor (var cy = 0; cy < checkbuf.height; cy += step) {\r\n\t\t\t\tvar i1 = (x + cx) * 4 + (y + cy) * bigbuf.width * 4;\r\n\t\t\t\tvar i2 = cx * 4 + cy * checkbuf.width * 4;\r\n\t\t\t\tvar d = 0;\r\n\t\t\t\td = d + Math.abs(bigbuf.data[i1 + 0] - checkbuf.data[i2 + 0]) | 0;\r\n\t\t\t\td = d + Math.abs(bigbuf.data[i1 + 1] - checkbuf.data[i2 + 1]) | 0;\r\n\t\t\t\td = d + Math.abs(bigbuf.data[i1 + 2] - checkbuf.data[i2 + 2]) | 0;\r\n\t\t\t\td *= checkbuf.data[i2 + 3] / 255;\r\n\t\t\t\tif (step == 1) { dif += d; }\r\n\t\t\t\tif (d > max) { return Infinity; }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn dif / checkbuf.width / checkbuf.height;\r\n}\r\n\r\n/**\r\n* Calculates the root mean square error between the two buffers at the given coordinate, this method can be used in situations with significant blur or \r\n* transparency, it does not bail early on non-matching images like simpleCompare does so it can be expected to be much slower when called often.\r\n* @returns The root mean square error beteen the images, high single pixel errors are penalized more than consisten low errors. return of 0 means perfect match.\r\n*/\r\nexport function simpleCompareRMSE(bigbuf: ImageData, checkbuf: ImageData, x: number, y: number) {\r\n\tif (x < 0 || y < 0) { throw new RangeError(); }\r\n\tif (x + checkbuf.width > bigbuf.width || y + checkbuf.height > bigbuf.height) { throw new RangeError(); }\r\n\r\n\tvar dif = 0;\r\n\tvar numpix = 0;\r\n\tfor (var cx = 0; cx < checkbuf.width; cx++) {\r\n\t\tfor (var cy = 0; cy < checkbuf.height; cy++) {\r\n\t\t\tvar i1 = (x + cx) * 4 + (y + cy) * bigbuf.width * 4;\r\n\t\t\tvar i2 = cx * 4 + cy * checkbuf.width * 4;\r\n\t\t\tvar d = 0;\r\n\t\t\td = d + Math.abs(bigbuf.data[i1 + 0] - checkbuf.data[i2 + 0]) | 0;\r\n\t\t\td = d + Math.abs(bigbuf.data[i1 + 1] - checkbuf.data[i2 + 1]) | 0;\r\n\t\t\td = d + Math.abs(bigbuf.data[i1 + 2] - checkbuf.data[i2 + 2]) | 0;\r\n\t\t\tvar weight = checkbuf.data[i2 + 3] / 255;\r\n\t\t\tnumpix += weight;\r\n\t\t\tdif += d * d * weight;\r\n\t\t}\r\n\t}\r\n\treturn Math.sqrt(dif / numpix);\r\n}\r\n\r\n/**\r\n* Returns the difference between two colors (scaled to the alpha of the second color)\r\n*/\r\nexport function coldif(r1: number, g1: number, b1: number, r2: number, g2: number, b2: number, a2: number) {\r\n\treturn (Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2)) * a2 / 255;//only applies alpha for 2nd buffer!\r\n}\r\n\r\n/**\r\n * Turns map of promises into a map that contains the resolved values after loading.\r\n * @param input\r\n */\r\nexport function asyncMap<T extends { [name: string]: Promise<any> }>(input: T) {\r\n\t//recusive types what xd\r\n\ttype subt = { [K in keyof T]: T[K] extends Promise<infer U> ? U : any };\r\n\tvar raw = {} as subt;\r\n\tvar promises: Promise<any>[] = [];\r\n\r\n\tfor (var a in input) {\r\n\t\tif (input.hasOwnProperty(a)) {\r\n\t\t\traw[a] = null!;\r\n\t\t\tpromises.push(input[a].then(function (a: keyof T, i: any) { raw[a] = i; r[a] = i; }.bind(null, a)));\r\n\t\t}\r\n\t}\r\n\tvar r = {} as subt & { promise: Promise<subt>, loaded: boolean, raw: subt };\r\n\tvar promise = Promise.all(promises).then(() => { r.loaded = true; return r; });\r\n\tObject.defineProperty(r, \"loaded\", { enumerable: false, value: false, writable: true });\r\n\tObject.defineProperty(r, \"promise\", { enumerable: false, value: promise });\r\n\tObject.defineProperty(r, \"raw\", { enumerable: false, value: raw });\r\n\treturn Object.assign(r, raw);\r\n}\r\n\r\n/**\r\n* Same as asyncMap, but casts the properties to ImageData in typescript\r\n*/\r\nexport function webpackImages<T extends { [name: string]: Promise<ImageData> }>(input: T) {\r\n\ttype subt = { [K in keyof T]: ImageData };\r\n\treturn asyncMap<{ [K in keyof T]: Promise<ImageData> }>(input) as any as { promise: Promise<subt>, loaded: boolean, raw: subt } & subt;\r\n}\r\n\r\nexport class ImageDataSet {\r\n\tbuffers: ImageData[] = [];\r\n\r\n\tmatchBest(img: ImageData, x: number, y: number, max?: number) {\r\n\t\tlet best: number | null = null;\r\n\t\tlet bestscore: number | undefined = max;\r\n\t\tfor (let a = 0; a < this.buffers.length; a++) {\r\n\t\t\tlet score = img.pixelCompare(this.buffers[a], x, y, bestscore)\r\n\t\t\tif (isFinite(score) && (bestscore == undefined || score < bestscore)) {\r\n\t\t\t\tbestscore = score;\r\n\t\t\t\tbest = a;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (best == null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn { index: best, score: bestscore };\r\n\t}\r\n\r\n\r\n\tstatic fromFilmStrip(baseimg: ImageData, width: number) {\r\n\t\tif ((baseimg.width % width) != 0) { throw new Error(\"slice size does not fit in base img\"); }\r\n\t\tlet r = new ImageDataSet();\r\n\t\tfor (let x = 0; x < baseimg.width; x += width) {\r\n\t\t\tr.buffers.push(baseimg.clone(new Rect(x, 0, width, baseimg.height)));\r\n\t\t}\r\n\t\treturn r;\r\n\t}\r\n\r\n\tstatic fromFilmStripUneven(baseimg: ImageData, widths: number[]) {\r\n\t\tlet r = new ImageDataSet()\r\n\t\tlet x = 0;\r\n\t\tfor (let w of widths) {\r\n\t\t\tr.buffers.push(baseimg.clone(new Rect(x, 0, w, baseimg.height)));\r\n\t\t\tx += w;\r\n\t\t\tif (x > baseimg.width) { throw new Error(\"sampling filmstrip outside bounds\"); }\r\n\t\t}\r\n\t\tif (x != baseimg.width) { throw new Error(\"unconsumed pixels left in film strip imagedata\"); }\r\n\t\treturn r;\r\n\t}\r\n\r\n\tstatic fromAtlas(baseimg: ImageData, slices: RectLike[]) {\r\n\t\tlet r = new ImageDataSet();\r\n\t\tfor (let slice of slices) {\r\n\t\t\tr.buffers.push(baseimg.clone(slice));\r\n\t\t}\r\n\t\treturn r;\r\n\t}\r\n}","import { ImgRefCtx } from \"./index\";\r\nimport * as ImageDetect from \"./imagedetect\";\r\nimport { ImgRef } from \"./imgref\";\r\n\r\ntype ErrorCode = \"noimg\" | \"notpng\" | \"invalidfile\";\r\ntype ImgCallback = (imgref: ImgRef) => any;\r\ntype ErrorCallback = (text: string, id: ErrorCode) => any;\r\nvar listeners: { cb: ImgCallback, error: ErrorCallback | undefined }[] = [];\r\nvar started = false;\r\nvar dndStarted = false;\r\nvar pasting = false;\r\nexport var lastref: ImgRef | null = null;\r\n\r\nexport function listen(func: ImgCallback, errorfunc?: ErrorCallback, dragndrop?: boolean) {\r\n\tlisteners.push({ cb: func, error: errorfunc });\r\n\r\n\tif (!started) { start(); }\r\n\tif (dragndrop && !dndStarted) { startDragNDrop(); }\r\n}\r\n\r\nexport function unlisten(func: ImgCallback) {\r\n\tlet i = listeners.findIndex(c => c.cb == func);\r\n\tif (i != -1) {\r\n\t\tlisteners.splice(i, 1);\r\n\t}\r\n}\r\n\r\n/**\r\n * currently used in multiple document situations (iframe), might be removed in the future\r\n */\r\nexport function triggerPaste(img: ImgRef) {\r\n\tlastref = img;\r\n\tfor (var a in listeners) { listeners[a].cb(lastref); }\r\n}\r\n\r\nfunction pasted(img: HTMLImageElement | HTMLCanvasElement) {\r\n\tpasting = false;\r\n\tlet cnv = img instanceof HTMLCanvasElement ? img : img.toCanvas();\r\n\ttriggerPaste(new ImgRefCtx(cnv));\r\n}\r\n\r\nfunction error(error: ErrorCode, mes: string) {\r\n\tpasting = false;\r\n\tfor (var a in listeners) {\r\n\t\tlisteners[a].error?.(mes, error);\r\n\t}\r\n}\r\n\r\nexport function startDragNDrop() {\r\n\tvar getitem = function (items: DataTransferItemList) {\r\n\t\tvar foundimage = \"\";\r\n\t\tfor (var a = 0; a < items.length; a++) {\r\n\t\t\tvar item = items[a];\r\n\t\t\tvar m = item.type.match(/^image\\/(\\w+)$/)\r\n\t\t\tif (m) {\r\n\t\t\t\tif (m[1] == \"png\") { return item; }\r\n\t\t\t\telse { foundimage = m[1]; }\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (foundimage) {\r\n\t\t\terror(\"notpng\", \"The image you uploaded is not a .png image. Other image type have compression noise and can't be used for image detection.\");\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\twindow.addEventListener(\"dragover\", function (e) {\r\n\t\te.preventDefault();\r\n\t});\r\n\twindow.addEventListener(\"drop\", function (e) {\r\n\t\tif (!e.dataTransfer) { return; }\r\n\t\tvar item = getitem(e.dataTransfer.items);\r\n\t\te.preventDefault();\r\n\t\tif (!item) { return; }\r\n\t\tfromFile(item.getAsFile());\r\n\t});\r\n}\r\n\r\nexport function start() {\r\n\tif (started) { return; }\r\n\tstarted = true;\r\n\r\n\t//determine if we have a clipboard api\r\n\t//try{a=new Event(\"clipboard\"); a=\"clipboardData\" in a;}\r\n\t//catch(e){a=false;}\r\n\tvar ischrome = !!navigator.userAgent.match(/Chrome/) && !navigator.userAgent.match(/Edge/);\r\n\t//old method breaks after chrome 41, revert to good old user agent sniffing\r\n\t//nvm, internet explorer (edge) decided that it wants to be chrome, however fails at delivering\r\n\r\n\t//turns out this one is interesting, edge is a hybrid between the paste api's\r\n\tvar apipasted = function (e: ClipboardEvent) {\r\n\t\tif (!e.clipboardData) { return; }\r\n\t\tfor (var a = 0; a < e.clipboardData.items.length; a++) {//loop all data types\r\n\t\t\tif (e.clipboardData.items[a].type.indexOf(\"image\") != -1) {\r\n\t\t\t\tvar file = e.clipboardData.items[a].getAsFile();\r\n\t\t\t\tvar img = new Image();\r\n\t\t\t\timg.src = (window.URL || (window as any).webkitURL).createObjectURL(file);\r\n\t\t\t\tif (img.width > 0) { pasted(img); }\r\n\t\t\t\telse { img.onload = function () { pasted(img); } }\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tif (ischrome) {\r\n\t\tdocument.addEventListener(\"paste\", apipasted);\r\n\t}\r\n\telse {\r\n\t\tvar catcher = document.createElement(\"div\");\r\n\t\tcatcher.setAttribute(\"contenteditable\", \"\");\r\n\t\tcatcher.className = \"forcehidden\";//retarded ie safety/bug, cant apply styles using js//TODO i don't even know what's going on\r\n\t\tcatcher.onpaste = function (e) {\r\n\t\t\tif (e.clipboardData && e.clipboardData.items) { apipasted(e); return; }\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tvar b = catcher.children[0] as HTMLImageElement\r\n\t\t\t\tif (!b || b.tagName != \"IMG\") { return; }\r\n\t\t\t\tvar img = new Image();\r\n\t\t\t\timg.src = b.src;\r\n\t\t\t\tvar a = img.src.match(/^data:([\\w\\/]+);/);\r\n\t\t\t\tif (img.width > 0) { pasted(img); }\r\n\t\t\t\telse { img.onload = function () { pasted(img) }; }\r\n\t\t\t\tcatcher.innerHTML = \"\";\r\n\t\t\t}, 1);\r\n\t\t};\r\n\t\tdocument.body.appendChild(catcher);\r\n\t}\r\n\r\n\t//detect if ctrl-v is pressed and focus catcher if needed\r\n\tdocument.addEventListener(\"keydown\", function (e) {\r\n\t\tif ((e.target as HTMLElement).tagName == \"INPUT\") { return; }\r\n\t\tif (e.keyCode != \"V\".charCodeAt(0) || !e.ctrlKey) { return; }\r\n\t\tpasting = true;\r\n\t\tsetTimeout(function () {\r\n\t\t\tif (pasting) { error(\"noimg\", \"You pressed Ctrl+V, but no image was pasted by your browser, make sure your clipboard contains an image, and not a link to an image.\"); }\r\n\t\t}, 1000);\r\n\t\tif (catcher) { catcher.focus(); }\r\n\t});\r\n}\r\n\r\nexport function fileDialog() {\r\n\tvar fileinput = document.createElement(\"input\");\r\n\tfileinput.type = \"file\";\r\n\tfileinput.accept = \"image/png\";\r\n\tfileinput.onchange = function () { if (fileinput.files && fileinput.files[0]) { fromFile(fileinput.files[0]); } };\r\n\tfileinput.click();\r\n\treturn fileinput;\r\n}\r\n\r\nfunction fromFile(file: File | null) {\r\n\tif (!file) { return; }\r\n\tvar reader = new FileReader();\r\n\treader.onload = function () {//TODO check if it's actually png\r\n\t\tvar bytearray = new Uint8Array(reader.result as ArrayBuffer);\r\n\t\tif (ImageDetect.isPngBuffer(bytearray)) {\r\n\t\t\tImageDetect.clearPngColorspace(bytearray);\r\n\t\t}\r\n\t\tvar blob = new Blob([bytearray], { type: \"image/png\" });\r\n\t\tvar img = new Image();\r\n\t\timg.onerror = () => error(\"invalidfile\", \"The file you uploaded could not be opened as an image.\",);\r\n\t\tvar bloburl = URL.createObjectURL(blob);\r\n\t\timg.src = bloburl;\r\n\t\tif (img.width > 0) { pasted(img); URL.revokeObjectURL(bloburl); }\r\n\t\telse { img.onload = function () { pasted(img); URL.revokeObjectURL(bloburl); }; }\r\n\t};\r\n\r\n\treader.readAsArrayBuffer(file);\r\n}"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ImgRef","constructor","x","y","w","h","t","width","height","read","Error","findSubimage","needle","sx","sy","toData","containsArea","rect","ImgRefCtx","img","CanvasRenderingContext2D","super","canvas","ctx","cnv","HTMLCanvasElement","toCanvas","getContext","getImageData","ImgRefBind","handle","transferImageData","ImgRefData","buf","r","ImageData","b","a","i1","i2","data","Rect","static","args","length","union","r2","Math","min","max","includePoint","inflate","intersect","overlaps","contains","containsPoint","requirefunction","polyfillRequire","requirefn","requireSharp","require","e","requireNodeCanvas","requireElectronCommon","imageDataToDrawable","nodecnv","createCanvas","flipBGRAtoRGBA","i","tmp","imageDataToFileBytes","format","quality","electronCommon","sharp","nativeImage","bufcpy","Buffer","from","slice","byteOffset","byteLength","createFromBitmap","toPNG","buffer","raw","channels","png","opts","webp","toBuffer","resolveWithObject","imageDataFromBase64","base64","imageDataFromBuffer","clearPngColorspace","createFromBuffer","pixels","toBitmap","size","getSize","pixbuf","Uint8ClampedArray","Promise","done","err","Image","onerror","onload","naturalWidth","naturalHeight","drawImage","src","globalvar","global","filltype","document","fillconstr","constr","arguments","createElement","imageData","createImageData","set","toDrawableData","putImageData","cx","cy","dx","dy","pixelOffset","getPixelHash","hash","clone","toImage","show","zoom","imgs","getElementsByClassName","maxImages","remove","el","classList","add","style","position","zIndex","left","top","background","cursor","imageRendering","outline","onclick","body","appendChild","console","error","getPixel","getPixelValueSum","getPixelInt","getColorDifference","g","abs","setPixel","color","Array","isArray","undefined","setPixelInt","toFileBytes","d","toBlob","FileReader","readAsArrayBuffer","Uint8Array","result","toPngBase64","str","toDataURL","indexOf","pixelCompare","copyTo","target","sourcex","sourcey","targetx","targety","targetwidth","thiswidth","copywidth","fastwidth","floor","thisdata","Int32Array","targetdata","it","is","HTMLImageElement","NoAlt1Error","message","Alt1Error","newestversion","hasAlt1","alt1","skinName","maxtransfer","openbrowser","url","openBrowser","window","open","requireAlt1","getdisplaybounds","screenX","screenY","screenWidth","screenHeight","capture","fromArgs","getRegion","decodeImageString","x1","ref","bindRegion","x2","bindGetRegion","captureHold","round","captureHoldScreen","bindScreenRegion","captureHoldFullRs","rsWidth","rsHeight","bindGetRegionBuffer","imagestring","bin","atob","bytes","offset","target_width","charCodeAt","encodeImageString","sw","sh","String","fromCharCode","btoa","mixColor","unmixColor","col","identifyApp","identifyAppUrl","resetEnvironment","cachedVersionInt","hasAlt1Version","versionstr","versionint","match","RangeError","convertAlt1Version","getMousePosition","pos","mousePosition","addResizeElement","right","bot","userResize","addEventListener","preventDefault","on","type","listener","events","push","removeListener","elist","splice","once","fn","ImageStreamReader","reader","framebuffer","reading","closed","pausedindex","pausedbuffer","streamreader","setFrameBuffer","close","cancel","nextImage","Date","now","readChunk","res","framedata","framesize","datalen","rel","captureAsync","encodeURIComponent","JSON","stringify","fetch","getReader","captureMultiAsync","areas","bufs","capts","captids","id","imgreader","capt","proms","results","all","captureStream","fps","framecb","errorcb","state","then","framenr","imageDataFromUrl","crossOrigin","fail","hdr","startsWith","imageDataFromFileBuffer","blob","Blob","URL","createObjectURL","revokeObjectURL","isPngBuffer","ancillary","chunkname","toLowerCase","end","crc","bitcrc","bit","k","haystackImgref","needleBuffer","TypeError","bindFindSubImg","needlestr","parse","findSubbuffer","haystack","needlestride","heystackstride","checkList","cw","ch","checklength","outer","simpleCompare","Infinity","bigbuf","checkbuf","dif","step","simpleCompareRMSE","numpix","weight","sqrt","coldif","r1","g1","b1","g2","b2","a2","asyncMap","input","promises","bind","promise","loaded","writable","assign","webpackImages","ImageDataSet","buffers","matchBest","best","bestscore","score","isFinite","index","baseimg","widths","slices","listeners","started","dndStarted","pasting","lastref","listen","func","errorfunc","dragndrop","cb","start","startDragNDrop","unlisten","findIndex","c","triggerPaste","pasted","mes","dataTransfer","item","items","foundimage","m","getitem","fromFile","getAsFile","ischrome","navigator","userAgent","apipasted","clipboardData","file","webkitURL","catcher","setAttribute","className","onpaste","setTimeout","children","tagName","innerHTML","keyCode","ctrlKey","focus","fileDialog","fileinput","accept","onchange","files","click","bytearray","bloburl"],"sourceRoot":""}