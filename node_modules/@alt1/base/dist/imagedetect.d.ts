import { ImgRef } from "./imgref";
import { RectLike } from ".";
/**
* Downloads an image and returns the ImageData
* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!
* @param url http(s) or data url to the image
*/
export declare function imageDataFromUrl(url: string): Promise<ImageData>;
/**
* Loads an ImageData object from a base64 encoded png image
* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!
* @param data a base64 encoded png image
*/
export declare function imageDataFromBase64(data: string): Promise<ImageData>;
/**
 * Loads an ImageData object directly from a png encoded file buffer
 * This method ensures that png color space headers are taken care off
 * @param data The bytes of a png file
 */
export declare function imageDataFromFileBuffer(data: Uint8Array): Promise<ImageData>;
/**
* Checks if a given byte array is a png file (by checking for ?PNG as first 4 bytes)
* @param bytes Raw bytes of the png file
*/
export declare function isPngBuffer(bytes: Uint8Array): boolean;
/**
* Resets the colorspace data in the png file.
* This makes sure the browser renders the exact colors in the file instead of filtering it in order to obtain the best real life representation of
* what it looked like on the authors screen. (this feature is often broken and not supported)
* For example a round trip printscreen -> open in browser results in different colors than the original
* @param data Raw bytes of the png file
*/
export declare function clearPngColorspace(data: Uint8Array): void;
/**
* finds the given needle ImageBuffer in the given haystack ImgRef this function uses the best optimized available
* code depending on the type of the haystack. It will use fast c# searching if the haystack is an ImgRefBind, js searching
* is used otherwise.
* the checklist argument is no longer used and should ignored or null/undefined
* The optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search the needle. The rectangle should be bigger than the needle
* @returns An array of points where the needle is found. The array is empty if none are found
*/
export declare function findSubimage(haystackImgref: ImgRef, needleBuffer: ImageData, sx?: number, sy?: number, sw?: number, sh?: number): {
    x: number;
    y: number;
}[];
/**
* Uses js to find the given needle ImageBuffer in the given haystack ImageBuffer. It is better to use the alt1.bind- functions in
* combination with a1nxt.findsubimg.
* the optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search.
* @returns An array of points where the needle is found. The array is empty if none are found
*/
export declare function findSubbuffer(haystack: ImageData, needle: ImageData, sx?: number, sy?: number, sw?: number, sh?: number): {
    x: number;
    y: number;
}[];
/**
* Compares two images and returns the average color difference per pixel between them
* @param max The max color difference at any point in the image before short circuiting the function and returning Infinity. set to -1 to always continue.
* @returns The average color difference per pixel or Infinity if the difference is more than max at any point in the image
*/
export declare function simpleCompare(bigbuf: ImageData, checkbuf: ImageData, x: number, y: number, max?: number): number;
/**
* Calculates the root mean square error between the two buffers at the given coordinate, this method can be used in situations with significant blur or
* transparency, it does not bail early on non-matching images like simpleCompare does so it can be expected to be much slower when called often.
* @returns The root mean square error beteen the images, high single pixel errors are penalized more than consisten low errors. return of 0 means perfect match.
*/
export declare function simpleCompareRMSE(bigbuf: ImageData, checkbuf: ImageData, x: number, y: number): number;
/**
* Returns the difference between two colors (scaled to the alpha of the second color)
*/
export declare function coldif(r1: number, g1: number, b1: number, r2: number, g2: number, b2: number, a2: number): number;
/**
 * Turns map of promises into a map that contains the resolved values after loading.
 * @param input
 */
export declare function asyncMap<T extends {
    [name: string]: Promise<any>;
}>(input: T): { [K in keyof T]: T[K] extends Promise<infer U> ? U : any; } & {
    promise: Promise<{ [K in keyof T]: T[K] extends Promise<infer U> ? U : any; }>;
    loaded: boolean;
    raw: { [K in keyof T]: T[K] extends Promise<infer U> ? U : any; };
};
/**
* Same as asyncMap, but casts the properties to ImageData in typescript
*/
export declare function webpackImages<T extends {
    [name: string]: Promise<ImageData>;
}>(input: T): {
    promise: Promise<{ [K in keyof T]: ImageData; }>;
    loaded: boolean;
    raw: { [K in keyof T]: ImageData; };
} & { [K in keyof T]: ImageData; };
export declare class ImageDataSet {
    buffers: ImageData[];
    matchBest(img: ImageData, x: number, y: number, max?: number): {
        index: number;
        score: number | undefined;
    } | null;
    static fromFilmStrip(baseimg: ImageData, width: number): ImageDataSet;
    static fromFilmStripUneven(baseimg: ImageData, widths: number[]): ImageDataSet;
    static fromAtlas(baseimg: ImageData, slices: RectLike[]): ImageDataSet;
}
//# sourceMappingURL=imagedetect.d.ts.map