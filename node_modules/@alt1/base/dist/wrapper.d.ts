import Rect, { RectLike } from "./rect";
import { ImgRefBind } from "./imgref";
import "./alt1api";
declare global {
    namespace alt1 {
        var events: {
            [event: string]: Alt1EventHandler[];
        };
        var capture: undefined | ((x: number, y: number, w: number, h: number) => Uint8ClampedArray);
        var captureAsync: undefined | ((x: number, y: number, w: number, h: number) => Promise<Uint8ClampedArray>);
        var captureMultiAsync: undefined | (<T extends {
            [id: string]: RectLike | null | undefined;
        }>(areas: T) => Promise<{
            [key in keyof T]: Uint8ClampedArray;
        }>);
        var bindGetRegionBuffer: undefined | ((id: number, x: number, y: number, width: number, height: number) => Uint8ClampedArray);
    }
}
/**
 * Thrown when a method is called that can not be used outside of Alt1
 */
export declare class NoAlt1Error extends Error {
    constructor();
}
/**
 * Thrown when the Alt1 API returns an invalid result
 * Errors of a different type are throw when internal Alt1 errors occur
 */
export declare class Alt1Error extends Error {
}
/**
 * The latest Alt1 version
 */
export declare var newestversion: string;
/**
 * Whether the Alt1 API is available
 */
export declare var hasAlt1: boolean;
/**
 * The name of the Alt1 interface skin. (Always "default" if running in a browser)
 */
export declare var skinName: string;
/**
 * Open a link in the default browser
 * @deprecated use window.open instead
 */
export declare function openbrowser(url: string): void;
/**
 * Throw if Alt1 API is not available
 */
export declare function requireAlt1(): void;
/**
 * Returns an object with a rectangle that spans all screens
 */
export declare function getdisplaybounds(): false | Rect;
/**
 * gets an imagebuffer with pixel data about the requested region
 */
export declare function capture(...args: [rect: RectLike] | [x: number, y: number, w: number, h: number]): ImageData;
/**
 * Makes alt1 bind an area of the rs client in memory without sending it to the js client
 * returns an imgref object which can be used to get pixel data using the imgreftobuf function
 * currently only one bind can exist per app and the ref in (v) will always be 1
 */
export declare function captureHold(x: number, y: number, w: number, h: number): ImgRefBind;
/**
 * Same as captureHoldRegion, but captures the screen instead of the rs client. it also uses screen coordinates instead and can capture outside of the rs client
 */
export declare function captureHoldScreen(x: number, y: number, w: number, h: number): false | ImgRefBind;
/**
 * bind the full rs window if the rs window can be detected by alt1, otherwise return the full screen
 */
export declare function captureHoldFullRs(): ImgRefBind;
/**
 * returns a subregion from a bound image
 * used internally in imgreftobuf if imgref is a bound image
 * @deprecated This should be handled internall by the imgrefbind.toData method
 */
export declare function transferImageData(handle: number, x: number, y: number, w: number, h: number): ImageData;
/**
 * decodes a returned string from alt1 to an imagebuffer
 */
export declare function decodeImageString(imagestring: string, target: ImageData, x: number, y: number, w: number, h: number): ImageData;
/**
 * encodes an imagebuffer to a string
 */
export declare function encodeImageString(buf: ImageData, sx?: number, sy?: number, sw?: number, sh?: number): string;
/**
 * mixes the given color into a single int. This format is used by alt1
 */
export declare function mixColor(r: number, g: number, b: number, a?: number): number;
export declare function unmixColor(col: number): [number, number, number];
export declare function identifyApp(url: string): void;
export declare function resetEnvironment(): void;
/**
 * checks if alt1 is running and at least the given version. versionstr should be a string with the version eg: 1.3.2
 * @param versionstr
 */
export declare function hasAlt1Version(versionstr: string): boolean;
/**
 * Gets the current cursor position in the game, returns null if the rs window is not active (alt1.rsActive)
 */
export declare function getMousePosition(): {
    x: number;
    y: number;
} | null;
/**
 * Registers a given HTML element as a frame border, when this element is dragged by the user the Alt1 frame will resize accordingly
 * Use the direction arguements to make a given direction stick to the mouse. eg. Only set left to true to make the element behave as the left border
 * Or set all to true to move the whole window. Not all combinations are permitted
 */
export declare function addResizeElement(el: HTMLElement, left: boolean, top: boolean, right: boolean, bot: boolean): void;
export declare type Alt1EventHandler = (e: any) => void;
/**
 * Add an event listener
 */
export declare function on<K extends keyof Alt1EventType>(type: K, listener: (ev: Alt1EventType[K]) => void): void;
/**
 * Removes an event listener
 */
export declare function removeListener<K extends keyof Alt1EventType>(type: K, listener: (ev: Alt1EventType[K]) => void): void;
/**
 * Listens for the event to fire once and then stops listening
 * @param event
 * @param cb
 */
export declare function once<K extends keyof Alt1EventType>(type: K, listener: (ev: Alt1EventType[K]) => void): void;
export interface Alt1EventType {
    "alt1pressed": {
        eventName: "alt1pressed";
        text: string;
        mouseAbs: {
            x: number;
            y: number;
        };
        mouseRs: {
            x: number;
            y: number;
        };
        x: number;
        y: number;
        rsLinked: boolean;
    };
    "menudetected": {
        eventName: "menudetected";
        rectangle: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
    };
    "rslinked": {
        eventName: "rslinked";
    };
    "rsunlinked": {
        eventName: "rsunlinked";
    };
    "permissionchanged": {
        eventName: "permissionchanged";
    };
    "daemonrun": {
        eventName: "daemonrun";
        result: {
            now: number;
            nextRun: number;
            state: string;
            messages: {
                [id: string]: {
                    title: string;
                    body: string;
                };
            };
            statusXml: string;
        };
    };
    "userevent": {
        eventName: "userevent";
        argument: string;
    };
    "rsfocus": {
        eventName: "rsfocus";
    };
    "rsblur": {
        eventName: "rsblur";
    };
}
/**
 * Used to read a set of images from a binary stream returned by the Alt1 API
 */
export declare class ImageStreamReader {
    private framebuffer;
    private streamreader;
    private pos;
    private reading;
    closed: boolean;
    private pausedindex;
    private pausedbuffer;
    constructor(reader: ReadableStreamReader<Uint8Array>, width: number, height: number);
    constructor(reader: ReadableStreamReader<Uint8Array>, framebuffer: ImageData);
    constructor(reader: ReadableStreamReader<Uint8Array>);
    /**
     *
     */
    setFrameBuffer(buffer: ImageData): void;
    /**
     * Closes the underlying stream and ends reading
     */
    close(): void;
    /**
     * Reads a single image from the stream
     */
    nextImage(): Promise<ImageData>;
    private readChunk;
}
/**
 * Asynchronously captures a section of the game screen
 */
export declare function captureAsync(...args: [rect: RectLike] | [x: number, y: number, width: number, height: number]): Promise<ImageData>;
/**
 * Asynchronously captures multple area's. This method captures the images in the same render frame if possible
 * @param areas
 */
export declare function captureMultiAsync<T extends {
    [id: string]: RectLike | null | undefined;
}>(areas: T): Promise<{ [K in keyof T]: ImageData | null; }>;
export declare type CaptureStreamResult = {
    x: number;
    y: number;
    width: number;
    height: number;
    framenr: number;
    close: () => void;
    closed: boolean;
};
/**
 * Starts capturing a realtime stream of the game. Make sure you keep reading the stream and close it when you're done or Alt1 WILL crash
 * @param framecb Called whenever a new frame is decoded
 * @param errorcb Called whenever an error occurs, the error is rethrown if not defined
 * @param fps Maximum fps of the stream
 */
export declare function captureStream(x: number, y: number, width: number, height: number, fps: number, framecb: (img: ImageData) => void, errorcb?: (e: Error) => void): CaptureStreamResult;
//# sourceMappingURL=wrapper.d.ts.map