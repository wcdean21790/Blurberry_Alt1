import * as a1lib from "./index";
declare global {
    interface ImageData {
        putImageData(buf: ImageData, cx: number, cy: number): void;
        pixelOffset(x: number, y: number): number;
        getPixelHash(rect: a1lib.RectLike): number;
        clone(rect: a1lib.RectLike): ImageData;
        show: {
            (x?: number, y?: number, zoom?: number): HTMLCanvasElement;
            maxImages: number;
        };
        toDrawableData(): ImageData;
        toImage(rect?: a1lib.RectLike): HTMLCanvasElement;
        getPixel(x: number, y: number): [number, number, number, number];
        getPixelValueSum(x: number, y: number): number;
        getPixelInt(x: number, y: number): number;
        getColorDifference(x: number, y: number, r: number, g: number, b: number, a?: number): number;
        setPixel(x: number, y: number, color: [number, number, number, number]): void;
        setPixel(x: number, y: number, r: number, g: number, b: number, a: number): void;
        setPixelInt(x: number, y: number, color: number): void;
        toFileBytes(format: "image/png" | "image/webp", quality?: any): Promise<Uint8Array>;
        toPngBase64(): string;
        pixelCompare(buf: ImageData, x?: number, y?: number, max?: number): number;
        copyTo(target: ImageData, sourcex: number, sourcey: number, width: number, height: number, targetx: number, targety: number): void;
    }
    interface HTMLImageElement {
        toBuffer(x?: number, y?: number, w?: number, h?: number): ImageData;
        toCanvas(x?: number, y?: number, w?: number, h?: number): HTMLCanvasElement;
    }
}
declare type ImageDataConstr = {
    prototype: ImageData;
    new (width: number, height: number): ImageData;
    new (array: Uint8ClampedArray, width: number, height: number): ImageData;
};
export declare var ImageData: ImageDataConstr;
export {};
//# sourceMappingURL=imagedata-extensions.d.ts.map